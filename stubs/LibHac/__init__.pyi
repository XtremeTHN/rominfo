import typing, clr, abc
from System import IEquatable_1, ReadOnlySpan_1, IDisposable, IComparable_1
from LibHac.Ncm import ProgramLocation
from LibHac.FsSrv.Impl import AccessControlBits
from LibHac.Arp import ArpClient
from LibHac.Diag import DiagClient
from LibHac.Fs import FileSystemClient
from LibHac.Lr import LrClient
from LibHac.Os import OsState, ITickGenerator
from LibHac.Sm import ServiceManagerClient
from LibHac.Fs.Fsa import IFileSystem
from LibHac.Common.Keys import KeySet
from LibHac.Mem import Buffer

class ApplicationId(IEquatable_1[ApplicationId]):
    def __init__(self, value: int) -> None: ...
    Value : int
    @classmethod
    @property
    def InvalidId(cls) -> ApplicationId: ...
    def GetHashCode(self) -> int: ...
    def __eq__(self, left: ApplicationId, right: ApplicationId) -> bool: ...
    def __ne__(self, left: ApplicationId, right: ApplicationId) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: ApplicationId) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class ArrayPoolMemoryResource(MemoryResource):
    def __init__(self) -> None: ...


class Horizon:
    def __init__(self, config: HorizonConfiguration) -> None: ...
    def CreatePrivilegedHorizonClient(self) -> HorizonClient: ...
    # Skipped CreateHorizonClient due to it being static, abstract and generic.

    CreateHorizonClient : CreateHorizonClient_MethodGroup
    class CreateHorizonClient_MethodGroup:
        @typing.overload
        def __call__(self) -> HorizonClient:...
        @typing.overload
        def __call__(self, location: ProgramLocation, fsPermissions: AccessControlBits.Bits) -> HorizonClient:...
        @typing.overload
        def __call__(self, location: ProgramLocation, fsAccessControlData: ReadOnlySpan_1[int], fsAccessControlDescriptor: ReadOnlySpan_1[int]) -> HorizonClient:...



class HorizonClient(IDisposable):
    @property
    def Arp(self) -> ArpClient: ...
    @property
    def Diag(self) -> DiagClient: ...
    @property
    def Fs(self) -> FileSystemClient: ...
    @property
    def Lr(self) -> LrClient: ...
    @property
    def Os(self) -> OsState: ...
    @property
    def Sm(self) -> ServiceManagerClient: ...
    def Dispose(self) -> None: ...


class HorizonConfiguration:
    def __init__(self) -> None: ...
    @property
    def TickGenerator(self) -> ITickGenerator: ...
    @TickGenerator.setter
    def TickGenerator(self, value: ITickGenerator) -> ITickGenerator: ...


class HorizonFactory(abc.ABC):
    @staticmethod
    def CreateWithDefaultFsConfig(config: HorizonConfiguration, rootFileSystem: IFileSystem, keySet: KeySet) -> Horizon: ...


class MemoryResource(abc.ABC):
    def Allocate(self, size: int, alignment: int = ...) -> Buffer: ...
    def Deallocate(self, buffer: clr.Reference[Buffer], alignment: int = ...) -> None: ...
    def IsEqual(self, other: MemoryResource) -> bool: ...


class Result(IEquatable_1[Result]):
    @typing.overload
    def __init__(self, module: int, description: int) -> None: ...
    @typing.overload
    def __init__(self, value: int) -> None: ...
    @property
    def Description(self) -> int: ...
    @property
    def ErrorCode(self) -> str: ...
    @property
    def Module(self) -> int: ...
    @classmethod
    @property
    def Success(cls) -> Result: ...
    @property
    def Value(self) -> int: ...
    def Catch(self) -> Result: ...
    def GetHashCode(self) -> int: ...
    def Handle(self) -> Result: ...
    def IgnoreResult(self) -> None: ...
    def IsFailure(self) -> bool: ...
    def IsSuccess(self) -> bool: ...
    def Log(self) -> Result: ...
    def LogConverted(self, originalResult: Result) -> Result: ...
    def Miss(self) -> Result: ...
    def __eq__(self, left: Result, right: Result) -> bool: ...
    def __ne__(self, left: Result, right: Result) -> bool: ...
    def Ret(self) -> Result: ...
    def Rethrow(self) -> Result: ...
    @staticmethod
    def SetLogger(logger: Result.IResultLogger) -> None: ...
    @staticmethod
    def SetNameResolver(nameResolver: Result.IResultNameResolver) -> None: ...
    def ThrowIfFailure(self) -> None: ...
    def ToString(self) -> str: ...
    def ToStringWithName(self) -> str: ...
    def TryGetResultName(self, name: clr.Reference[str]) -> bool: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Result) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...


    class Base:
        @typing.overload
        def __init__(self, module: int, description: int) -> None: ...
        @typing.overload
        def __init__(self, module: int, descriptionStart: int, descriptionEnd: int) -> None: ...
        @property
        def DescriptionRangeEnd(self) -> int: ...
        @property
        def DescriptionRangeStart(self) -> int: ...
        @property
        def Module(self) -> int: ...
        @property
        def Value(self) -> Result: ...
        def Catch(self) -> Result: ...
        def Handle(self) -> Result: ...
        def Includes(self, result: Result) -> bool: ...
        def Log(self) -> Result: ...
        def LogConverted(self, originalResult: Result) -> Result: ...
        def Miss(self) -> Result: ...
        def Rethrow(self) -> Result: ...

        class Abstract:
            @typing.overload
            def __init__(self, module: int, description: int) -> None: ...
            @typing.overload
            def __init__(self, module: int, descriptionStart: int, descriptionEnd: int) -> None: ...
            @property
            def DescriptionRangeEnd(self) -> int: ...
            @property
            def DescriptionRangeStart(self) -> int: ...
            @property
            def Module(self) -> int: ...
            def Includes(self, result: Result) -> bool: ...



    class IResultLogger(typing.Protocol):
        @abc.abstractmethod
        def LogConvertedResult(self, result: Result, originalResult: Result) -> None: ...
        @abc.abstractmethod
        def LogResult(self, result: Result) -> None: ...


    class IResultNameResolver(typing.Protocol):
        @abc.abstractmethod
        def TryResolveName(self, result: Result, name: clr.Reference[str]) -> bool: ...



class TimeSpan(IComparable_1[TimeSpan], IEquatable_1[TimeSpan]):
    @typing.overload
    def __init__(self, _: int) -> None: ...
    @typing.overload
    def __init__(self, ts: TimeSpanType) -> None: ...
    def CompareTo(self, other: TimeSpan) -> int: ...
    @staticmethod
    def FromDays(days: int) -> TimeSpan: ...
    @staticmethod
    def FromHours(hours: int) -> TimeSpan: ...
    @staticmethod
    def FromMicroSeconds(microSeconds: int) -> TimeSpan: ...
    @staticmethod
    def FromMilliSeconds(milliSeconds: int) -> TimeSpan: ...
    @staticmethod
    def FromMinutes(minutes: int) -> TimeSpan: ...
    @staticmethod
    def FromNanoSeconds(nanoSeconds: int) -> TimeSpan: ...
    @staticmethod
    def FromSeconds(seconds: int) -> TimeSpan: ...
    def GetDays(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def GetHours(self) -> int: ...
    def GetMicroSeconds(self) -> int: ...
    def GetMilliSeconds(self) -> int: ...
    def GetMinutes(self) -> int: ...
    def GetNanoSeconds(self) -> int: ...
    def GetSeconds(self) -> int: ...
    def __add__(self, left: TimeSpan, right: TimeSpan) -> TimeSpan: ...
    def __eq__(self, left: TimeSpan, right: TimeSpan) -> bool: ...
    def __gt__(self, left: TimeSpan, right: TimeSpan) -> bool: ...
    def __ge__(self, left: TimeSpan, right: TimeSpan) -> bool: ...
    # Operator not supported op_Implicit(ts: TimeSpan)
    def __ne__(self, left: TimeSpan, right: TimeSpan) -> bool: ...
    def __lt__(self, left: TimeSpan, right: TimeSpan) -> bool: ...
    def __le__(self, left: TimeSpan, right: TimeSpan) -> bool: ...
    def __sub__(self, left: TimeSpan, right: TimeSpan) -> TimeSpan: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: TimeSpan) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class TimeSpanType(IComparable_1[TimeSpanType], IEquatable_1[TimeSpanType]):
    def CompareTo(self, other: TimeSpanType) -> int: ...
    @staticmethod
    def FromDays(days: int) -> TimeSpanType: ...
    @staticmethod
    def FromHours(hours: int) -> TimeSpanType: ...
    @staticmethod
    def FromMicroSeconds(microSeconds: int) -> TimeSpanType: ...
    @staticmethod
    def FromMilliSeconds(milliSeconds: int) -> TimeSpanType: ...
    @staticmethod
    def FromMinutes(minutes: int) -> TimeSpanType: ...
    @staticmethod
    def FromNanoSeconds(nanoSeconds: int) -> TimeSpanType: ...
    @staticmethod
    def FromSeconds(seconds: int) -> TimeSpanType: ...
    def GetDays(self) -> int: ...
    def GetHashCode(self) -> int: ...
    def GetHours(self) -> int: ...
    def GetMicroSeconds(self) -> int: ...
    def GetMilliSeconds(self) -> int: ...
    def GetMinutes(self) -> int: ...
    def GetNanoSeconds(self) -> int: ...
    def GetSeconds(self) -> int: ...
    def __add__(self, left: TimeSpanType, right: TimeSpanType) -> TimeSpanType: ...
    def __eq__(self, left: TimeSpanType, right: TimeSpanType) -> bool: ...
    def __gt__(self, left: TimeSpanType, right: TimeSpanType) -> bool: ...
    def __ge__(self, left: TimeSpanType, right: TimeSpanType) -> bool: ...
    def __ne__(self, left: TimeSpanType, right: TimeSpanType) -> bool: ...
    def __lt__(self, left: TimeSpanType, right: TimeSpanType) -> bool: ...
    def __le__(self, left: TimeSpanType, right: TimeSpanType) -> bool: ...
    def __sub__(self, left: TimeSpanType, right: TimeSpanType) -> TimeSpanType: ...
    def ToString(self) -> str: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: TimeSpanType) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



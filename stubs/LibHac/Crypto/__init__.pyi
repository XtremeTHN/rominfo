import typing, clr, abc
from System import Span_1, ReadOnlySpan_1
from LibHac.Common import Buffer16
from System.Security.Cryptography import RSAParameters
from System.Numerics import BigInteger
from LibHac.Common.FixedArrays import Array128_1, Array256_1, Array3_1

class Aes(abc.ABC):
    BlockSize : int
    KeySize128 : int
    @staticmethod
    def CalculateCmac(mac: Span_1[int], data: ReadOnlySpan_1[int], key: ReadOnlySpan_1[int]) -> None: ...
    @staticmethod
    def CreateCbcDecryptor(key: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], preferDotNetCrypto: bool = ...) -> ICipher: ...
    @staticmethod
    def CreateCbcEncryptor(key: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], preferDotNetCrypto: bool = ...) -> ICipher: ...
    @staticmethod
    def CreateCtrDecryptor(key: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], preferDotNetCrypto: bool = ...) -> ICipherWithIv: ...
    @staticmethod
    def CreateCtrEncryptor(key: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], preferDotNetCrypto: bool = ...) -> ICipherWithIv: ...
    @staticmethod
    def CreateEcbDecryptor(key: ReadOnlySpan_1[int], preferDotNetCrypto: bool = ...) -> ICipher: ...
    @staticmethod
    def CreateEcbEncryptor(key: ReadOnlySpan_1[int], preferDotNetCrypto: bool = ...) -> ICipher: ...
    @staticmethod
    def CreateXtsDecryptor(key1: ReadOnlySpan_1[int], key2: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], preferDotNetCrypto: bool = ...) -> ICipherWithIv: ...
    @staticmethod
    def CreateXtsEncryptor(key1: ReadOnlySpan_1[int], key2: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], preferDotNetCrypto: bool = ...) -> ICipherWithIv: ...
    @staticmethod
    def DecryptCbc128(input: ReadOnlySpan_1[int], output: Span_1[int], key: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], preferDotNetCrypto: bool = ...) -> int: ...
    @staticmethod
    def DecryptCtr128(input: ReadOnlySpan_1[int], output: Span_1[int], key: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], preferDotNetCrypto: bool = ...) -> int: ...
    @staticmethod
    def DecryptEcb128(input: ReadOnlySpan_1[int], output: Span_1[int], key: ReadOnlySpan_1[int], preferDotNetCrypto: bool = ...) -> int: ...
    @staticmethod
    def DecryptXts128(input: ReadOnlySpan_1[int], output: Span_1[int], key1: ReadOnlySpan_1[int], key2: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], preferDotNetCrypto: bool = ...) -> int: ...
    @staticmethod
    def EncryptCbc128(input: ReadOnlySpan_1[int], output: Span_1[int], key: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], preferDotNetCrypto: bool = ...) -> int: ...
    @staticmethod
    def EncryptCtr128(input: ReadOnlySpan_1[int], output: Span_1[int], key: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], preferDotNetCrypto: bool = ...) -> int: ...
    @staticmethod
    def EncryptEcb128(input: ReadOnlySpan_1[int], output: Span_1[int], key: ReadOnlySpan_1[int], preferDotNetCrypto: bool = ...) -> int: ...
    @staticmethod
    def EncryptXts128(input: ReadOnlySpan_1[int], output: Span_1[int], key1: ReadOnlySpan_1[int], key2: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], preferDotNetCrypto: bool = ...) -> int: ...
    @staticmethod
    def IsAesNiSupported() -> bool: ...


class AesCbcDecryptor(ICipher):
    def __init__(self, key: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int]) -> None: ...
    def Transform(self, input: ReadOnlySpan_1[int], output: Span_1[int]) -> int: ...


class AesCbcDecryptorNi(ICipherWithIv):
    def __init__(self, key: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int]) -> None: ...
    @property
    def Iv(self) -> clr.Reference[Buffer16]: ...
    def Transform(self, input: ReadOnlySpan_1[int], output: Span_1[int]) -> int: ...


class AesCbcEncryptor(ICipher):
    def __init__(self, key: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int]) -> None: ...
    def Transform(self, input: ReadOnlySpan_1[int], output: Span_1[int]) -> int: ...


class AesCbcEncryptorNi(ICipherWithIv):
    def __init__(self, key: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int]) -> None: ...
    @property
    def Iv(self) -> clr.Reference[Buffer16]: ...
    def Transform(self, input: ReadOnlySpan_1[int], output: Span_1[int]) -> int: ...


class AesCmac:
    @property
    def Data(self) -> Span_1[int]: ...
    @property
    def Data64(self) -> Span_1[int]: ...
    @property
    def DataRo(self) -> ReadOnlySpan_1[int]: ...
    @property
    def DataRo64(self) -> ReadOnlySpan_1[int]: ...
    def IsZeros(self) -> bool: ...
    # Operator not supported op_Implicit(value: AesCmac&)
    # Operator not supported op_Implicit(value: AesCmac&)
    def ToString(self) -> str: ...


class AesCtrCipher(ICipherWithIv):
    def __init__(self, key: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int]) -> None: ...
    @property
    def Iv(self) -> clr.Reference[Buffer16]: ...
    def Transform(self, input: ReadOnlySpan_1[int], output: Span_1[int]) -> int: ...


class AesCtrCipherNi(ICipherWithIv):
    def __init__(self, key: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int]) -> None: ...
    @property
    def Iv(self) -> clr.Reference[Buffer16]: ...
    def Transform(self, input: ReadOnlySpan_1[int], output: Span_1[int]) -> int: ...


class AesEcbDecryptor(ICipher):
    def __init__(self, key: ReadOnlySpan_1[int]) -> None: ...
    def Transform(self, input: ReadOnlySpan_1[int], output: Span_1[int]) -> int: ...


class AesEcbDecryptorNi(ICipher):
    def __init__(self, key: ReadOnlySpan_1[int]) -> None: ...
    def Transform(self, input: ReadOnlySpan_1[int], output: Span_1[int]) -> int: ...


class AesEcbEncryptor(ICipher):
    def __init__(self, key: ReadOnlySpan_1[int]) -> None: ...
    def Transform(self, input: ReadOnlySpan_1[int], output: Span_1[int]) -> int: ...


class AesEcbEncryptorNi(ICipher):
    def __init__(self, key: ReadOnlySpan_1[int]) -> None: ...
    def Transform(self, input: ReadOnlySpan_1[int], output: Span_1[int]) -> int: ...


class AesIv:
    @property
    def Data(self) -> Span_1[int]: ...
    @property
    def Data64(self) -> Span_1[int]: ...
    @property
    def DataRo(self) -> ReadOnlySpan_1[int]: ...
    @property
    def DataRo64(self) -> ReadOnlySpan_1[int]: ...
    def IsZeros(self) -> bool: ...
    # Operator not supported op_Implicit(value: AesIv&)
    # Operator not supported op_Implicit(value: AesIv&)
    def ToString(self) -> str: ...


class AesKey:
    @property
    def Data(self) -> Span_1[int]: ...
    @property
    def Data64(self) -> Span_1[int]: ...
    @property
    def DataRo(self) -> ReadOnlySpan_1[int]: ...
    @property
    def DataRo64(self) -> ReadOnlySpan_1[int]: ...
    def IsZeros(self) -> bool: ...
    # Operator not supported op_Implicit(value: AesKey&)
    # Operator not supported op_Implicit(value: AesKey&)
    def ToString(self) -> str: ...


class AesXtsDecryptor(ICipherWithIv):
    def __init__(self, key1: ReadOnlySpan_1[int], key2: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int]) -> None: ...
    @property
    def Iv(self) -> clr.Reference[Buffer16]: ...
    def Transform(self, input: ReadOnlySpan_1[int], output: Span_1[int]) -> int: ...


class AesXtsDecryptorNi(ICipherWithIv):
    def __init__(self, key1: ReadOnlySpan_1[int], key2: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int]) -> None: ...
    @property
    def Iv(self) -> clr.Reference[Buffer16]: ...
    def Transform(self, input: ReadOnlySpan_1[int], output: Span_1[int]) -> int: ...


class AesXtsEncryptor(ICipherWithIv):
    def __init__(self, key1: ReadOnlySpan_1[int], key2: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int]) -> None: ...
    @property
    def Iv(self) -> clr.Reference[Buffer16]: ...
    def Transform(self, input: ReadOnlySpan_1[int], output: Span_1[int]) -> int: ...


class AesXtsEncryptorNi(ICipherWithIv):
    def __init__(self, key1: ReadOnlySpan_1[int], key2: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int]) -> None: ...
    @property
    def Iv(self) -> clr.Reference[Buffer16]: ...
    def Transform(self, input: ReadOnlySpan_1[int], output: Span_1[int]) -> int: ...


class AesXtsKey:
    DataKey : AesKey
    TweakKey : AesKey
    @property
    def Data(self) -> Span_1[int]: ...
    @property
    def Data64(self) -> Span_1[int]: ...
    @property
    def DataRo(self) -> ReadOnlySpan_1[int]: ...
    @property
    def DataRo64(self) -> ReadOnlySpan_1[int]: ...
    @property
    def SubKeys(self) -> Span_1[AesKey]: ...
    def IsZeros(self) -> bool: ...
    # Operator not supported op_Implicit(value: AesXtsKey&)
    # Operator not supported op_Implicit(value: AesXtsKey&)
    def ToString(self) -> str: ...


class HmacSha256(abc.ABC):
    HashSize : int
    @staticmethod
    def GenerateHmacSha256(outMac: Span_1[int], data: ReadOnlySpan_1[int], key: ReadOnlySpan_1[int]) -> None: ...


class ICipher(typing.Protocol):
    @abc.abstractmethod
    def Transform(self, input: ReadOnlySpan_1[int], output: Span_1[int]) -> int: ...


class ICipherWithIv(ICipher, typing.Protocol):
    @property
    def Iv(self) -> clr.Reference[Buffer16]: ...


class IHash(typing.Protocol):
    @abc.abstractmethod
    def GetHash(self, hashBuffer: Span_1[int]) -> None: ...
    @abc.abstractmethod
    def Initialize(self) -> None: ...
    @abc.abstractmethod
    def Update(self, data: ReadOnlySpan_1[int]) -> None: ...


class Rsa(abc.ABC):
    MaximumExponentSize2048Pss : int
    ModulusSize2048Pss : int
    @staticmethod
    def VerifyRsa2048Pkcs1Sha256(signature: ReadOnlySpan_1[int], modulus: ReadOnlySpan_1[int], exponent: ReadOnlySpan_1[int], message: ReadOnlySpan_1[int]) -> bool: ...
    @staticmethod
    def VerifyRsa2048PssSha256(signature: ReadOnlySpan_1[int], modulus: ReadOnlySpan_1[int], exponent: ReadOnlySpan_1[int], message: ReadOnlySpan_1[int]) -> bool: ...
    @staticmethod
    def VerifyRsa2048PssSha256WithHash(signature: ReadOnlySpan_1[int], modulus: ReadOnlySpan_1[int], exponent: ReadOnlySpan_1[int], message: ReadOnlySpan_1[int]) -> bool: ...
    # Skipped RecoverParameters due to it being static, abstract and generic.

    RecoverParameters : RecoverParameters_MethodGroup
    class RecoverParameters_MethodGroup:
        @typing.overload
        def __call__(self, n: ReadOnlySpan_1[int], e: ReadOnlySpan_1[int], d: ReadOnlySpan_1[int]) -> RSAParameters:...
        @typing.overload
        def __call__(self, n: BigInteger, e: BigInteger, d: BigInteger) -> RSAParameters:...



class RsaFullKey:
    Dp : Array128_1[int]
    Dq : Array128_1[int]
    InverseQ : Array128_1[int]
    Modulus : Array256_1[int]
    P : Array128_1[int]
    PrivateExponent : Array256_1[int]
    PublicExponent : Array3_1[int]
    Q : Array128_1[int]


class RsaKey:
    Modulus : Array256_1[int]
    PublicExponent : Array3_1[int]


class Sha256(abc.ABC):
    DigestSize : int
    @staticmethod
    def CreateSha256Generator() -> IHash: ...
    @staticmethod
    def GenerateSha256Hash(data: ReadOnlySpan_1[int], hashBuffer: Span_1[int]) -> None: ...


class Sha256Generator(IHash):
    def __init__(self) -> None: ...
    def GetHash(self, hashBuffer: Span_1[int]) -> None: ...
    def Initialize(self) -> None: ...
    def Update(self, data: ReadOnlySpan_1[int]) -> None: ...


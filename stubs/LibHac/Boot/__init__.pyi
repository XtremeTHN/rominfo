import typing, clr
from LibHac.Crypto import AesCmac, AesIv, AesKey
from LibHac.Common.FixedArrays import Array144_1, Array112_1, Array16_1, Array32_1, Array256_1, Array12_1, Array4_1, Array3_1
from System import Span_1, ReadOnlySpan_1, IDisposable
from LibHac import Result
from LibHac.Common.Keys import KeySet
from LibHac.Common import SharedRef_1, U8Span, UniqueRef_1
from LibHac.Fs import IStorage

class EncryptedKeyBlob:
    Cmac : AesCmac
    Counter : AesIv
    Payload : Array144_1[int]
    @property
    def Bytes(self) -> Span_1[int]: ...
    @property
    def BytesRo(self) -> ReadOnlySpan_1[int]: ...
    def IsZeros(self) -> bool: ...
    # Operator not supported op_Implicit(value: EncryptedKeyBlob&)
    def ToString(self) -> str: ...


class KeyBlob:
    MasterKek : AesKey
    Package1Key : AesKey
    Unused : Array112_1[int]
    @property
    def Bytes(self) -> Span_1[int]: ...
    @property
    def BytesRo(self) -> ReadOnlySpan_1[int]: ...
    def IsZeros(self) -> bool: ...
    # Operator not supported op_Implicit(value: KeyBlob&)
    def ToString(self) -> str: ...


class Package1:
    def __init__(self) -> None: ...
    @property
    def IsDecrypted(self) -> bool: ...
    @IsDecrypted.setter
    def IsDecrypted(self, value: bool) -> bool: ...
    @property
    def IsMariko(self) -> bool: ...
    @IsMariko.setter
    def IsMariko(self, value: bool) -> bool: ...
    @property
    def IsModern(self) -> bool: ...
    @IsModern.setter
    def IsModern(self, value: bool) -> bool: ...
    @property
    def KeyRevision(self) -> int: ...
    @KeyRevision.setter
    def KeyRevision(self, value: int) -> int: ...
    @property
    def MarikoOemHeader(self) -> clr.Reference[Package1MarikoOemHeader]: ...
    @property
    def MetaData(self) -> clr.Reference[Package1MetaData]: ...
    @property
    def Pk11Header(self) -> clr.Reference[Package1Pk11Header]: ...
    @property
    def Pk11Mac(self) -> clr.Reference[Array16_1[int]]: ...
    @property
    def Pk11Size(self) -> int: ...
    @Pk11Size.setter
    def Pk11Size(self, value: int) -> int: ...
    @property
    def Stage1Footer(self) -> clr.Reference[Package1Stage1Footer]: ...
    def GetSectionOffset(self, sectionType: Package1Section) -> int: ...
    def GetSectionSize(self, sectionType: Package1Section) -> int: ...
    def Initialize(self, keySet: KeySet, storage: clr.Reference[SharedRef_1[IStorage]]) -> Result: ...
    def OpenDecryptedPackage1Storage(self) -> IStorage: ...
    def OpenDecryptedWarmBootStorage(self) -> IStorage: ...
    def OpenNxBootloaderStorage(self) -> IStorage: ...
    def OpenSectionStorage(self, sectionType: Package1Section) -> IStorage: ...
    def OpenSecureMonitorStorage(self) -> IStorage: ...
    def OpenWarmBootStorage(self) -> IStorage: ...


class Package1MarikoOemHeader:
    AesMac : Array16_1[int]
    EntryPoint : int
    Hash : Array32_1[int]
    LoadAddress : int
    Reserved : Array16_1[int]
    RsaSig : Array256_1[int]
    Salt : Array32_1[int]
    Size : int
    Version : int


class Package1MetaData:
    BootloaderHash : int
    KeyGeneration : int
    LoaderHash : int
    Reserved : int
    SecureMonitorHash : int
    Version : int
    @property
    def BuildDate(self) -> U8Span: ...
    @property
    def Iv(self) -> ReadOnlySpan_1[int]: ...


class Package1Pk11Header:
    BootloaderOffset : int
    BootloaderSize : int
    ExpectedMagic : int
    Magic : int
    Reserved : int
    SecureMonitorOffset : int
    SecureMonitorSize : int
    WarmBootOffset : int
    WarmBootSize : int


class Package1Section(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Bootloader : Package1Section # 0
    SecureMonitor : Package1Section # 1
    WarmBoot : Package1Section # 2


class Package1Stage1Footer:
    Iv : Array16_1[int]
    Pk11Size : int
    Reserved : Array12_1[int]


class Package2Header:
    Meta : Package2Meta
    Signature : Array256_1[int]
    def VerifySignature(self, modulus: ReadOnlySpan_1[int], data: ReadOnlySpan_1[int]) -> Result: ...


class Package2Meta:
    BootloaderVersion : int
    EntryPoint : int
    ExpectedMagicValue : int
    HeaderIv : Array16_1[int]
    Magic : int
    Package2Version : int
    Padding40 : Array16_1[int]
    Padding58 : Array4_1[int]
    Padding6C : Array4_1[int]
    Padding7C : Array4_1[int]
    PaddingE0 : Array32_1[int]
    PayloadHashes : Array3_1[Array32_1[int]]
    PayloadIvs : Array3_1[Array16_1[int]]
    PayloadOffsets : Array3_1[int]
    PayloadSizes : Array3_1[int]
    def GetKeyGeneration(self) -> int: ...
    def GetPayloadFileOffset(self, index: int) -> int: ...
    def GetSize(self) -> int: ...
    def Verify(self) -> Result: ...


class Package2StorageReader(IDisposable):
    def __init__(self) -> None: ...
    @property
    def Header(self) -> clr.Reference[Package2Header]: ...
    def Dispose(self) -> None: ...
    def Initialize(self, keySet: KeySet, storage: clr.Reference[SharedRef_1[IStorage]]) -> Result: ...
    def OpenDecryptedPackage(self, outPackageStorage: clr.Reference[UniqueRef_1[IStorage]]) -> Result: ...
    def OpenIni(self, outIniStorage: clr.Reference[UniqueRef_1[IStorage]]) -> Result: ...
    def OpenKernel(self, outKernelStorage: clr.Reference[UniqueRef_1[IStorage]]) -> Result: ...
    def OpenPayload(self, outPayloadStorage: clr.Reference[UniqueRef_1[IStorage]], index: int) -> Result: ...
    def Verify(self) -> Result: ...
    def VerifyMeta(self) -> Result: ...
    def VerifyPayloads(self) -> Result: ...
    def VerifySignature(self) -> Result: ...


import typing, clr, abc
from LibHac.Fs import IStorage, ValueSubStorage, OperationId, SaveDataExtraData, SaveDataSpaceId, IBufferManager, Path, FileSystemClient, HashSalt, Int64, OpenMode, SubStorage
from LibHac import Result, MemoryResource
from LibHac.Common import UniqueRef_1, SharedRef_1, U8Span, Validity
from System import ReadOnlySpan_1, Span_1, MulticastDelegate, IAsyncResult, AsyncCallback, IDisposable, UIntPtr, Memory_1, Array_1, Func_1
from System.Reflection import MethodInfo
from LibHac.Common.FixedArrays import Array8_1, Array3_1, Array32_1, Array6_1, Array5_1, Array16_1, Array2_1, Array256_1, Array48_1, Array4_1
from LibHac.Fs.Fsa import IFileSystem, IAttributeFileSystem, IDirectory, IFile, OpenDirectoryMode
from LibHac.Os import SdkRecursiveMutex, Semaphore, ILockable, UniqueLock_1
from LibHac.FsSystem.Impl import IBlockCacheManagerRange, IBlockCacheManagerEntry_1
from LibHac.Mem import Buffer
from LibHac.Util import Optional_1
from LibHac.FsSrv import FileSystemServer
from System.Collections.Generic import IEnumerator_1, LinkedListNode_1
from System.IO import FileSystemInfo, DirectoryInfo, FileStream, FileAccess, FileMode, BinaryReader

class AesCtrCounterExtendedStorage(IStorage):
    def __init__(self) -> None: ...
    BlockSize : int
    IvSize : int
    KeySize : int
    NodeSize : int
    @staticmethod
    def CreateExternalDecryptor(outDecryptor: clr.Reference[UniqueRef_1[AesCtrCounterExtendedStorage.IDecryptor]], decryptFunction: AesCtrCounterExtendedStorage.DecryptFunction, keyIndex: int, keyGeneration: int) -> Result: ...
    @staticmethod
    def CreateSoftwareDecryptor(outDecryptor: clr.Reference[UniqueRef_1[AesCtrCounterExtendedStorage.IDecryptor]]) -> Result: ...
    def Dispose(self) -> None: ...
    def FinalizeObject(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def Initialize(self, allocator: MemoryResource, key: ReadOnlySpan_1[int], secureValue: int, counterOffset: int, dataStorage: clr.Reference[ValueSubStorage], nodeStorage: clr.Reference[ValueSubStorage], entryStorage: clr.Reference[ValueSubStorage], entryCount: int, decryptor: clr.Reference[UniqueRef_1[AesCtrCounterExtendedStorage.IDecryptor]]) -> Result: ...
    def IsInitialized(self) -> bool: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    @staticmethod
    def QueryEntryStorageSize(entryCount: int) -> int: ...
    @staticmethod
    def QueryHeaderStorageSize() -> int: ...
    @staticmethod
    def QueryNodeStorageSize(entryCount: int) -> int: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...

    class DecryptFunction(MulticastDelegate):
        def __init__(self, object: typing.Any, method: int) -> None: ...
        @property
        def Method(self) -> MethodInfo: ...
        @property
        def Target(self) -> typing.Any: ...
        def BeginInvoke(self, destination: Span_1[int], index: int, generation: int, encryptedKey: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
        def EndInvoke(self, result: IAsyncResult) -> Result: ...
        def Invoke(self, destination: Span_1[int], index: int, generation: int, encryptedKey: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int]) -> Result: ...


    class Entry:
        EncryptionValue : AesCtrCounterExtendedStorage.Entry.Encryption
        Generation : int
        Offset : Array8_1[int]
        Reserved : Array3_1[int]
        def GetOffset(self) -> int: ...
        def SetOffset(self, value: int) -> None: ...

        class Encryption(typing.SupportsInt):
            @typing.overload
            def __init__(self, value : int) -> None: ...
            @typing.overload
            def __init__(self, value : int, force_if_true: bool) -> None: ...
            def __int__(self) -> int: ...
            
            # Values:
            Encrypted : AesCtrCounterExtendedStorage.Entry.Encryption # 0
            NotEncrypted : AesCtrCounterExtendedStorage.Entry.Encryption # 1



    class IDecryptor(IDisposable, typing.Protocol):
        @abc.abstractmethod
        def Decrypt(self, destination: Span_1[int], encryptedKey: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int]) -> Result: ...
        @abc.abstractmethod
        def HasExternalDecryptionKey(self) -> bool: ...



class AesCtrStorage(IStorage):
    @typing.overload
    def __init__(self, baseStorage: IStorage, key: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int]) -> None: ...
    @typing.overload
    def __init__(self, baseStorage: clr.Reference[SharedRef_1[IStorage]], key: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int]) -> None: ...
    BlockSize : int
    IvSize : int
    KeySize : int
    def Dispose(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    @staticmethod
    def MakeIv(outIv: Span_1[int], upperIv: int, offset: int) -> None: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...


class AesXtsStorage(IStorage):
    @typing.overload
    def __init__(self, baseStorage: IStorage, key1: ReadOnlySpan_1[int], key2: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], blockSize: int) -> None: ...
    @typing.overload
    def __init__(self, baseStorage: clr.Reference[SharedRef_1[IStorage]], key1: ReadOnlySpan_1[int], key2: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], blockSize: int) -> None: ...
    AesBlockSize : int
    IvSize : int
    KeySize : int
    def Dispose(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    @staticmethod
    def MakeAesXtsIv(outIv: Span_1[int], offset: int, blockSize: int) -> None: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...


class AesXtsStorageExternal(IStorage):
    @typing.overload
    def __init__(self, baseStorage: IStorage, key1: ReadOnlySpan_1[int], key2: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], blockSize: int, encryptFunction: CryptAesXtsFunction, decryptFunction: CryptAesXtsFunction) -> None: ...
    @typing.overload
    def __init__(self, baseStorage: clr.Reference[SharedRef_1[IStorage]], key1: ReadOnlySpan_1[int], key2: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], blockSize: int, encryptFunction: CryptAesXtsFunction, decryptFunction: CryptAesXtsFunction) -> None: ...
    AesBlockSize : int
    IvSize : int
    KeySize : int
    def Dispose(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...


class AlignmentMatchingStorage_GenericClasses(abc.ABCMeta):
    Generic_AlignmentMatchingStorage_GenericClasses_AlignmentMatchingStorage_2_TDataAlignment = typing.TypeVar('Generic_AlignmentMatchingStorage_GenericClasses_AlignmentMatchingStorage_2_TDataAlignment')
    Generic_AlignmentMatchingStorage_GenericClasses_AlignmentMatchingStorage_2_TBufferAlignment = typing.TypeVar('Generic_AlignmentMatchingStorage_GenericClasses_AlignmentMatchingStorage_2_TBufferAlignment')
    def __getitem__(self, types : typing.Tuple[typing.Type[Generic_AlignmentMatchingStorage_GenericClasses_AlignmentMatchingStorage_2_TDataAlignment], typing.Type[Generic_AlignmentMatchingStorage_GenericClasses_AlignmentMatchingStorage_2_TBufferAlignment]]) -> typing.Type[AlignmentMatchingStorage_2[Generic_AlignmentMatchingStorage_GenericClasses_AlignmentMatchingStorage_2_TDataAlignment, Generic_AlignmentMatchingStorage_GenericClasses_AlignmentMatchingStorage_2_TBufferAlignment]]: ...

AlignmentMatchingStorage : AlignmentMatchingStorage_GenericClasses

AlignmentMatchingStorage_2_TDataAlignment = typing.TypeVar('AlignmentMatchingStorage_2_TDataAlignment')
AlignmentMatchingStorage_2_TBufferAlignment = typing.TypeVar('AlignmentMatchingStorage_2_TBufferAlignment')
class AlignmentMatchingStorage_2(typing.Generic[AlignmentMatchingStorage_2_TDataAlignment, AlignmentMatchingStorage_2_TBufferAlignment], IStorage):
    @typing.overload
    def __init__(self, baseStorage: clr.Reference[SharedRef_1[IStorage]]) -> None: ...
    @typing.overload
    def __init__(self, baseStorage: IStorage) -> None: ...
    @classmethod
    @property
    def BufferAlign(cls) -> int: ...
    @classmethod
    @property
    def DataAlign(cls) -> int: ...
    @classmethod
    @property
    def DataAlignMax(cls) -> int: ...
    def Dispose(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...


class AlignmentMatchingStorageImpl(abc.ABC):
    @staticmethod
    def GetRoundUpDifference(value: int, alignment: int) -> int: ...
    # Skipped GetRoundDownDifference due to it being static, abstract and generic.

    GetRoundDownDifference : GetRoundDownDifference_MethodGroup
    class GetRoundDownDifference_MethodGroup:
        def __call__(self, value: int, alignment: int) -> int:...
        # Method GetRoundDownDifference(value : Int64, alignment : UInt32) was skipped since it collides with above method

    # Skipped Read due to it being static, abstract and generic.

    Read : Read_MethodGroup
    class Read_MethodGroup:
        @typing.overload
        def __call__(self, storage: IStorage, workBuffer: Span_1[int], dataAlignment: int, bufferAlignment: int, offset: int, destination: Span_1[int]) -> Result:...
        @typing.overload
        def __call__(self, storage: clr.Reference[SharedRef_1[IStorage]], workBuffer: Span_1[int], dataAlignment: int, bufferAlignment: int, offset: int, destination: Span_1[int]) -> Result:...

    # Skipped Write due to it being static, abstract and generic.

    Write : Write_MethodGroup
    class Write_MethodGroup:
        @typing.overload
        def __call__(self, storage: IStorage, workBuffer: Span_1[int], dataAlignment: int, bufferAlignment: int, offset: int, source: ReadOnlySpan_1[int]) -> Result:...
        @typing.overload
        def __call__(self, storage: clr.Reference[SharedRef_1[IStorage]], subBuffer: Span_1[int], dataAlignment: int, bufferAlignment: int, offset: int, source: ReadOnlySpan_1[int]) -> Result:...



class AlignmentMatchingStorageInBulkRead_GenericClasses(abc.ABCMeta):
    Generic_AlignmentMatchingStorageInBulkRead_GenericClasses_AlignmentMatchingStorageInBulkRead_1_TBufferAlignment = typing.TypeVar('Generic_AlignmentMatchingStorageInBulkRead_GenericClasses_AlignmentMatchingStorageInBulkRead_1_TBufferAlignment')
    def __getitem__(self, types : typing.Type[Generic_AlignmentMatchingStorageInBulkRead_GenericClasses_AlignmentMatchingStorageInBulkRead_1_TBufferAlignment]) -> typing.Type[AlignmentMatchingStorageInBulkRead_1[Generic_AlignmentMatchingStorageInBulkRead_GenericClasses_AlignmentMatchingStorageInBulkRead_1_TBufferAlignment]]: ...

AlignmentMatchingStorageInBulkRead : AlignmentMatchingStorageInBulkRead_GenericClasses

AlignmentMatchingStorageInBulkRead_1_TBufferAlignment = typing.TypeVar('AlignmentMatchingStorageInBulkRead_1_TBufferAlignment')
class AlignmentMatchingStorageInBulkRead_1(typing.Generic[AlignmentMatchingStorageInBulkRead_1_TBufferAlignment], IStorage):
    @typing.overload
    def __init__(self, baseStorage: IStorage, dataAlignment: int) -> None: ...
    @typing.overload
    def __init__(self, baseStorage: clr.Reference[SharedRef_1[IStorage]], dataAlignment: int) -> None: ...
    @classmethod
    @property
    def BufferAlign(cls) -> int: ...
    def Dispose(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...


class AlignmentMatchingStoragePooledBuffer_GenericClasses(abc.ABCMeta):
    Generic_AlignmentMatchingStoragePooledBuffer_GenericClasses_AlignmentMatchingStoragePooledBuffer_1_TBufferAlignment = typing.TypeVar('Generic_AlignmentMatchingStoragePooledBuffer_GenericClasses_AlignmentMatchingStoragePooledBuffer_1_TBufferAlignment')
    def __getitem__(self, types : typing.Type[Generic_AlignmentMatchingStoragePooledBuffer_GenericClasses_AlignmentMatchingStoragePooledBuffer_1_TBufferAlignment]) -> typing.Type[AlignmentMatchingStoragePooledBuffer_1[Generic_AlignmentMatchingStoragePooledBuffer_GenericClasses_AlignmentMatchingStoragePooledBuffer_1_TBufferAlignment]]: ...

AlignmentMatchingStoragePooledBuffer : AlignmentMatchingStoragePooledBuffer_GenericClasses

AlignmentMatchingStoragePooledBuffer_1_TBufferAlignment = typing.TypeVar('AlignmentMatchingStoragePooledBuffer_1_TBufferAlignment')
class AlignmentMatchingStoragePooledBuffer_1(typing.Generic[AlignmentMatchingStoragePooledBuffer_1_TBufferAlignment], IStorage):
    @typing.overload
    def __init__(self, baseStorage: IStorage, dataAlign: int) -> None: ...
    @typing.overload
    def __init__(self, baseStorage: clr.Reference[SharedRef_1[IStorage]], dataAlign: int) -> None: ...
    @classmethod
    @property
    def BufferAlign(cls) -> int: ...
    def Dispose(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...


class AlignmentMatchingStorageSize1(IAlignmentMatchingStorageSize):
    pass


class AlignmentMatchingStorageSize16(IAlignmentMatchingStorageSize):
    pass


class AlignmentMatchingStorageSize512(IAlignmentMatchingStorageSize):
    pass


class ApplicationTemporaryFileSystem(IFileSystem, ISaveDataExtraDataAccessor):
    def __init__(self) -> None: ...
    def CommitExtraData(self, updateTimeStamp: bool) -> Result: ...
    def ReadExtraData(self, extraData: clr.Reference[SaveDataExtraData]) -> Result: ...
    def RegisterExtraDataAccessorObserver(self, observer: ISaveDataExtraDataAccessorObserver, spaceId: SaveDataSpaceId, saveDataId: int) -> None: ...
    def WriteExtraData(self, extraData: clr.Reference[SaveDataExtraData]) -> Result: ...


class BitmapUtils(abc.ABC):
    @staticmethod
    def ILog2(value: int) -> int: ...


class BlockCacheBufferedStorage(IStorage):
    def __init__(self) -> None: ...
    def Commit(self) -> Result: ...
    def Dispose(self) -> None: ...
    def FinalizeObject(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def Initialize(self, bufferManager: IBufferManager, mutex: SdkRecursiveMutex, data: IStorage, dataSize: int, sizeBytesVerificationBlock: int, maxCacheEntries: int, useRealDataCache: bool, bufferLevel: int, useKeepBurstMode: bool, isWritable: bool) -> Result: ...
    def IsEnabledKeepBurstMode(self) -> bool: ...
    def OnRollback(self) -> Result: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetKeepBurstMode(self, isEnabled: bool) -> None: ...
    def SetRealDataCache(self, isEnabled: bool) -> None: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...

    class AccessRange(IBlockCacheManagerRange):
        @property
        def Offset(self) -> int: ...
        @Offset.setter
        def Offset(self, value: int) -> int: ...
        @property
        def Size(self) -> int: ...
        @Size.setter
        def Size(self, value: int) -> int: ...
        def GetEndOffset(self) -> int: ...
        def IsIncluded(self, offset: int) -> int: ...


    class CacheEntry(IBlockCacheManagerEntry_1[BlockCacheBufferedStorage.AccessRange]):
        @property
        def Age(self) -> int: ...
        @Age.setter
        def Age(self, value: int) -> int: ...
        @property
        def Buffer(self) -> Buffer: ...
        @Buffer.setter
        def Buffer(self, value: Buffer) -> Buffer: ...
        @property
        def Handle(self) -> int: ...
        @Handle.setter
        def Handle(self, value: int) -> int: ...
        @property
        def IsCached(self) -> bool: ...
        @IsCached.setter
        def IsCached(self, value: bool) -> bool: ...
        @property
        def IsFlushing(self) -> bool: ...
        @IsFlushing.setter
        def IsFlushing(self, value: bool) -> bool: ...
        @property
        def IsValid(self) -> bool: ...
        @IsValid.setter
        def IsValid(self, value: bool) -> bool: ...
        @property
        def IsWriteBack(self) -> bool: ...
        @IsWriteBack.setter
        def IsWriteBack(self, value: bool) -> bool: ...
        @property
        def Range(self) -> BlockCacheBufferedStorage.AccessRange: ...
        def Invalidate(self) -> None: ...
        def IsAllocated(self) -> bool: ...



class BucketTree(IDisposable):
    def __init__(self) -> None: ...
    def Dispose(self) -> None: ...
    def FinalizeObject(self) -> None: ...
    def Find(self, visitor: clr.Reference[BucketTree.Visitor], virtualAddress: int) -> Result: ...
    def GetAllocator(self) -> MemoryResource: ...
    def GetEntryCount(self) -> int: ...
    def GetOffsets(self, offsets: clr.Reference[BucketTree.Offsets]) -> Result: ...
    def InvalidateCache(self) -> Result: ...
    def IsEmpty(self) -> bool: ...
    def IsInitialized(self) -> bool: ...
    @staticmethod
    def QueryEntryStorageSize(nodeSize: int, entrySize: int, entryCount: int) -> int: ...
    @staticmethod
    def QueryHeaderStorageSize() -> int: ...
    @staticmethod
    def QueryNodeStorageSize(nodeSize: int, entrySize: int, entryCount: int) -> int: ...
    # Skipped Initialize due to it being static, abstract and generic.

    Initialize : Initialize_MethodGroup
    class Initialize_MethodGroup:
        @typing.overload
        def __call__(self, nodeSize: int, endOffset: int) -> None:...
        @typing.overload
        def __call__(self, allocator: MemoryResource, nodeStorage: clr.Reference[ValueSubStorage], entryStorage: clr.Reference[ValueSubStorage], nodeSize: int, entrySize: int, entryCount: int) -> Result:...


    class BucketTreeNode_GenericClasses(abc.ABCMeta):
        Generic_BucketTreeNode_GenericClasses_BucketTreeNode_1_TEntry = typing.TypeVar('Generic_BucketTreeNode_GenericClasses_BucketTreeNode_1_TEntry')
        def __getitem__(self, types : typing.Type[Generic_BucketTreeNode_GenericClasses_BucketTreeNode_1_TEntry]) -> typing.Type[BucketTree.BucketTreeNode_1[Generic_BucketTreeNode_GenericClasses_BucketTreeNode_1_TEntry]]: ...

    BucketTreeNode : BucketTreeNode_GenericClasses

    BucketTreeNode_1_TEntry = typing.TypeVar('BucketTreeNode_1_TEntry')
    class BucketTreeNode_1(typing.Generic[BucketTreeNode_1_TEntry]):
        BucketTreeNode_1_TEntry = BucketTree.BucketTreeNode_1_TEntry
        def __init__(self, buffer: Span_1[int]) -> None: ...
        def GetBeginOffset(self) -> int: ...
        def GetCount(self) -> int: ...
        def GetEndOffset(self) -> int: ...
        def GetL2BeginOffset(self) -> int: ...
        # Skipped GetArray due to it being static, abstract and generic.

        GetArray : GetArray_MethodGroup[BucketTreeNode_1_TEntry]
        GetArray_MethodGroup_BucketTreeNode_1_TEntry = typing.TypeVar('GetArray_MethodGroup_BucketTreeNode_1_TEntry')
        class GetArray_MethodGroup(typing.Generic[GetArray_MethodGroup_BucketTreeNode_1_TEntry]):
            GetArray_MethodGroup_BucketTreeNode_1_TEntry = BucketTree.BucketTreeNode_1.GetArray_MethodGroup_BucketTreeNode_1_TEntry
            def __getitem__(self, t:typing.Type[GetArray_1_T1]) -> GetArray_1[GetArray_MethodGroup_BucketTreeNode_1_TEntry, GetArray_1_T1]: ...

            GetArray_1_BucketTreeNode_1_TEntry = typing.TypeVar('GetArray_1_BucketTreeNode_1_TEntry')
            GetArray_1_T1 = typing.TypeVar('GetArray_1_T1')
            class GetArray_1(typing.Generic[GetArray_1_BucketTreeNode_1_TEntry, GetArray_1_T1]):
                GetArray_1_BucketTreeNode_1_TEntry = BucketTree.BucketTreeNode_1.GetArray_MethodGroup.GetArray_1_BucketTreeNode_1_TEntry
                GetArray_1_TElement = BucketTree.BucketTreeNode_1.GetArray_MethodGroup.GetArray_1_T1
                def __call__(self) -> ReadOnlySpan_1[GetArray_1_TElement]:...

            def __call__(self) -> ReadOnlySpan_1[GetArray_MethodGroup_BucketTreeNode_1_TEntry]:...



    class Builder:
        def __init__(self) -> None: ...
        def Finalize(self, endOffset: int) -> Result: ...
        def Initialize(self, allocator: MemoryResource, headerStorage: clr.Reference[ValueSubStorage], nodeStorage: clr.Reference[ValueSubStorage], entryStorage: clr.Reference[ValueSubStorage], nodeSize: int, entrySize: int, entryCount: int) -> Result: ...
        # Skipped Add due to it being static, abstract and generic.

        Add : Add_MethodGroup
        class Add_MethodGroup:
            def __getitem__(self, t:typing.Type[Add_1_T1]) -> Add_1[Add_1_T1]: ...

            Add_1_T1 = typing.TypeVar('Add_1_T1')
            class Add_1(typing.Generic[Add_1_T1]):
                Add_1_T = BucketTree.Builder.Add_MethodGroup.Add_1_T1
                def __call__(self, entry: clr.Reference[Add_1_T]) -> Result:...




    class ContinuousReadingInfo:
        def CanDo(self) -> bool: ...
        def CheckNeedScan(self) -> bool: ...
        def Done(self) -> None: ...
        def GetReadSize(self) -> int: ...
        def IsDone(self) -> bool: ...
        def Reset(self) -> None: ...
        def SetReadSize(self, readSize: int) -> None: ...
        def SetSkipCount(self, count: int) -> None: ...


    class Header:
        EntryCount : int
        Magic : int
        Version : int
        def Format(self, entryCount: int) -> None: ...
        def Verify(self) -> Result: ...


    class IContinuousReadingEntry(typing.Protocol):
        @property
        def FragmentSizeMax(self) -> int: ...
        @abc.abstractmethod
        def GetPhysicalOffset(self) -> int: ...
        @abc.abstractmethod
        def GetVirtualOffset(self) -> int: ...
        @abc.abstractmethod
        def IsFragment(self) -> bool: ...


    class NodeHeader:
        EntryCount : int
        Index : int
        OffsetEnd : int
        def Verify(self, nodeIndex: int, nodeSize: int, entrySize: int) -> Result: ...


    class Offsets:
        EndOffset : int
        StartOffset : int
        # Skipped IsInclude due to it being static, abstract and generic.

        IsInclude : IsInclude_MethodGroup
        class IsInclude_MethodGroup:
            @typing.overload
            def __call__(self, offset: int) -> bool:...
            @typing.overload
            def __call__(self, offset: int, size: int) -> bool:...



    class Visitor:
        def __init__(self) -> None: ...
        @property
        def Ref(self) -> clr.Reference[BucketTree.Visitor]: ...
        def CanMoveNext(self) -> bool: ...
        def CanMovePrevious(self) -> bool: ...
        def Dispose(self) -> None: ...
        def GetTreeOffsets(self) -> BucketTree.Offsets: ...
        def IsValid(self) -> bool: ...
        def MoveNext(self) -> Result: ...
        def MovePrevious(self) -> Result: ...
        # Skipped Get due to it being static, abstract and generic.

        Get : Get_MethodGroup
        class Get_MethodGroup:
            def __getitem__(self, t:typing.Type[Get_1_T1]) -> Get_1[Get_1_T1]: ...

            Get_1_T1 = typing.TypeVar('Get_1_T1')
            class Get_1(typing.Generic[Get_1_T1]):
                Get_1_T = BucketTree.Visitor.Get_MethodGroup.Get_1_T1
                def __call__(self) -> clr.Reference[Get_1_T]:...


        # Skipped ScanContinuousReading due to it being static, abstract and generic.

        ScanContinuousReading : ScanContinuousReading_MethodGroup
        class ScanContinuousReading_MethodGroup:
            def __getitem__(self, t:typing.Type[ScanContinuousReading_1_T1]) -> ScanContinuousReading_1[ScanContinuousReading_1_T1]: ...

            ScanContinuousReading_1_T1 = typing.TypeVar('ScanContinuousReading_1_T1')
            class ScanContinuousReading_1(typing.Generic[ScanContinuousReading_1_T1]):
                ScanContinuousReading_1_TEntry = BucketTree.Visitor.ScanContinuousReading_MethodGroup.ScanContinuousReading_1_T1
                def __call__(self, info: clr.Reference[BucketTree.ContinuousReadingInfo], offset: int, size: int) -> Result:...





class BufferedStorage(IStorage):
    def __init__(self) -> None: ...
    def Dispose(self) -> None: ...
    def EnableBulkRead(self) -> None: ...
    def FinalizeObject(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetBufferManager(self) -> IBufferManager: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def Initialize(self, baseStorage: clr.Reference[ValueSubStorage], bufferManager: IBufferManager, blockSize: int, bufferCount: int) -> Result: ...
    def InvalidateCaches(self) -> None: ...
    def IsInitialized(self) -> bool: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...


class CompressedStorage(IStorage, IAsynchronousAccessSplitter):
    def __init__(self) -> None: ...
    NodeSize : int
    def Dispose(self) -> None: ...
    def FinalizeObject(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def Initialize(self, allocatorForBucketTree: MemoryResource, allocatorForCacheManager: IBufferManager, dataStorage: clr.Reference[ValueSubStorage], nodeStorage: clr.Reference[ValueSubStorage], entryStorage: clr.Reference[ValueSubStorage], bucketTreeEntryCount: int, blockSizeMax: int, continuousReadingSizeMax: int, getDecompressorFunc: GetDecompressorFunction, cacheSize0: int, cacheSize1: int, maxCacheEntries: int) -> Result: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def QueryAppropriateOffset(self, offsetAppropriate: clr.Reference[int], startOffset: int, accessSize: int, alignmentSize: int) -> Result: ...
    @staticmethod
    def QueryEntryStorageSize(entryCount: int) -> int: ...
    @staticmethod
    def QueryNodeStorageSize(entryCount: int) -> int: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...

    class CacheManager(IDisposable):
        def __init__(self) -> None: ...
        def Dispose(self) -> None: ...
        def FinalizeObject(self) -> None: ...
        def Initialize(self, allocator: IBufferManager, storageSize: int, cacheSize0: int, cacheSize1: int, maxCacheEntries: int) -> Result: ...
        def Invalidate(self) -> None: ...
        def Read(self, core: CompressedStorage.CompressedStorageCore, offset: int, buffer: Span_1[int]) -> Result: ...

        class AccessRange:
            IsBlockAlignmentRequired : bool
            PhysicalSize : int
            VirtualOffset : int
            VirtualSize : int
            def GetEndVirtualOffset(self) -> int: ...


        class CacheEntry(IBlockCacheManagerEntry_1[CompressedStorage.CacheManager.Range]):
            @property
            def Age(self) -> int: ...
            @Age.setter
            def Age(self, value: int) -> int: ...
            @property
            def Buffer(self) -> Buffer: ...
            @Buffer.setter
            def Buffer(self, value: Buffer) -> Buffer: ...
            @property
            def Handle(self) -> int: ...
            @Handle.setter
            def Handle(self, value: int) -> int: ...
            @property
            def IsCached(self) -> bool: ...
            @IsCached.setter
            def IsCached(self, value: bool) -> bool: ...
            @property
            def IsFlushing(self) -> None: ...
            @IsFlushing.setter
            def IsFlushing(self, value: bool) -> None: ...
            @property
            def IsValid(self) -> bool: ...
            @IsValid.setter
            def IsValid(self, value: bool) -> bool: ...
            @property
            def IsWriteBack(self) -> bool: ...
            @IsWriteBack.setter
            def IsWriteBack(self, value: bool) -> bool: ...
            @property
            def Range(self) -> CompressedStorage.CacheManager.Range: ...
            @Range.setter
            def Range(self, value: CompressedStorage.CacheManager.Range) -> CompressedStorage.CacheManager.Range: ...
            def Invalidate(self) -> None: ...
            def IsAllocated(self) -> bool: ...


        class Range(IBlockCacheManagerRange):
            @property
            def Offset(self) -> int: ...
            @Offset.setter
            def Offset(self, value: int) -> int: ...
            @property
            def Size(self) -> int: ...
            @Size.setter
            def Size(self, value: int) -> int: ...
            def GetEndOffset(self) -> int: ...
            def IsIncluded(self, offset: int) -> bool: ...



    class CompressedStorageCore(IDisposable):
        def __init__(self) -> None: ...
        def Dispose(self) -> None: ...
        def FinalizeObject(self) -> None: ...
        def GetSize(self, size: clr.Reference[int]) -> Result: ...
        def Initialize(self, allocatorForBucketTree: MemoryResource, dataStorage: clr.Reference[ValueSubStorage], nodeStorage: clr.Reference[ValueSubStorage], entryStorage: clr.Reference[ValueSubStorage], bucketTreeEntryCount: int, blockSizeMax: int, continuousReadingSizeMax: int, getDecompressorFunc: GetDecompressorFunction) -> Result: ...
        def Invalidate(self) -> Result: ...
        def OperateEntry(self, offset: int, size: int, func: CompressedStorage.CompressedStorageCore.OperatePerEntryFunc) -> Result: ...
        def OperatePerEntry(self, offset: int, size: int, func: CompressedStorage.CompressedStorageCore.OperatePerEntryFunc) -> Result: ...
        def QueryAppropriateOffsetForAsynchronousAccess(self, offsetAppropriate: clr.Reference[int], offset: int, accessSize: int, alignmentSize: int) -> Result: ...
        def QueryRange(self, buffer: Span_1[int], offset: int, size: int) -> Result: ...
        def Read(self, offset: int, size: int, func: CompressedStorage.CompressedStorageCore.ReadFunc) -> Result: ...

        class OperateEntryFunc(MulticastDelegate):
            def __init__(self, object: typing.Any, method: int) -> None: ...
            @property
            def Method(self) -> MethodInfo: ...
            @property
            def Target(self) -> typing.Any: ...
            def BeginInvoke(self, offset: int, size: int, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
            def EndInvoke(self, result: IAsyncResult) -> Result: ...
            def Invoke(self, offset: int, size: int) -> Result: ...


        class OperatePerEntryFunc(MulticastDelegate):
            def __init__(self, object: typing.Any, method: int) -> None: ...
            @property
            def Method(self) -> MethodInfo: ...
            @property
            def Target(self) -> typing.Any: ...
            def BeginInvoke(self, isContinuous: clr.Reference[bool], entry: clr.Reference[CompressedStorage.Entry], virtualDataSize: int, offsetInEntry: int, readSize: int, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
            def EndInvoke(self, isContinuous: clr.Reference[bool], entry: clr.Reference[CompressedStorage.Entry], result: IAsyncResult) -> Result: ...
            def Invoke(self, isContinuous: clr.Reference[bool], entry: clr.Reference[CompressedStorage.Entry], virtualDataSize: int, offsetInEntry: int, readSize: int) -> Result: ...


        class ReadFunc(MulticastDelegate):
            def __init__(self, object: typing.Any, method: int) -> None: ...
            @property
            def Method(self) -> MethodInfo: ...
            @property
            def Target(self) -> typing.Any: ...
            def BeginInvoke(self, sizeBufferRequired: int, readImplFunc: CompressedStorage.CompressedStorageCore.ReadImplFunc, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
            def EndInvoke(self, result: IAsyncResult) -> Result: ...
            def Invoke(self, sizeBufferRequired: int, readImplFunc: CompressedStorage.CompressedStorageCore.ReadImplFunc) -> Result: ...


        class ReadImplFunc(MulticastDelegate):
            def __init__(self, object: typing.Any, method: int) -> None: ...
            @property
            def Method(self) -> MethodInfo: ...
            @property
            def Target(self) -> typing.Any: ...
            def BeginInvoke(self, buffer: Span_1[int], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
            def EndInvoke(self, result: IAsyncResult) -> Result: ...
            def Invoke(self, buffer: Span_1[int]) -> Result: ...



    class Entry:
        CompressionLevel : int
        CompressionType : CompressionType
        PhysicalOffset : int
        PhysicalSize : int
        VirtualOffset : int
        def GetPhysicalSize(self) -> int: ...



class CompressionType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    None_ : CompressionType # 0
    Zeroed : CompressionType # 1
    Lz4 : CompressionType # 3
    Unknown : CompressionType # 4


class CompressionTypeUtility(abc.ABC):
    @staticmethod
    def IsBlockAlignmentRequired(type: CompressionType) -> bool: ...
    @staticmethod
    def IsDataStorageAccessRequired(type: CompressionType) -> bool: ...
    @staticmethod
    def IsRandomAccessible(type: CompressionType) -> bool: ...
    @staticmethod
    def IsUnknownType(type: CompressionType) -> bool: ...


class ConcatenationFileSystem(IFileSystem):
    @typing.overload
    def __init__(self, baseFileSystem: clr.Reference[UniqueRef_1[IAttributeFileSystem]]) -> None: ...
    @typing.overload
    def __init__(self, baseFileSystem: clr.Reference[UniqueRef_1[IAttributeFileSystem]], internalFileSize: int) -> None: ...
    DefaultInternalFileSize : int
    def Dispose(self) -> None: ...
    def GetFileSize(self, size: clr.Reference[int], path: clr.Reference[Path]) -> Result: ...


class CryptAesXtsFunction(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, dest: Span_1[int], key1: ReadOnlySpan_1[int], key2: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> Result: ...
    def Invoke(self, dest: Span_1[int], key1: ReadOnlySpan_1[int], key2: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int]) -> Result: ...


class DecompressorFunction(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, destination: Span_1[int], source: ReadOnlySpan_1[int], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> Result: ...
    def Invoke(self, destination: Span_1[int], source: ReadOnlySpan_1[int]) -> Result: ...


class DecryptAesCtrFunction(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, dest: Span_1[int], keyIndex: int, keyGeneration: int, encryptedKey: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> Result: ...
    def Invoke(self, dest: Span_1[int], keyIndex: int, keyGeneration: int, encryptedKey: ReadOnlySpan_1[int], iv: ReadOnlySpan_1[int], source: ReadOnlySpan_1[int]) -> Result: ...


class DefaultAsynchronousAccessSplitter(IAsynchronousAccessSplitter):
    def __init__(self) -> None: ...
    def Dispose(self) -> None: ...
    def QueryAppropriateOffset(self, offsetAppropriate: clr.Reference[int], startOffset: int, accessSize: int, alignmentSize: int) -> Result: ...
    def QueryInvocationCount(self, count: clr.Reference[int], startOffset: int, endOffset: int, accessSize: int, alignmentSize: int) -> Result: ...


class DirectorySaveDataFileSystem(ISaveDataFileSystem):
    @typing.overload
    def __init__(self, baseFileSystem: IFileSystem, fsClient: FileSystemClient = ...) -> None: ...
    @typing.overload
    def __init__(self, baseFileSystem: clr.Reference[UniqueRef_1[IFileSystem]], fsClient: FileSystemClient = ...) -> None: ...
    def CommitExtraData(self, updateTimeStamp: bool) -> Result: ...
    def Dispose(self) -> None: ...
    def GetSaveDataId(self) -> int: ...
    def GetSaveDataSpaceId(self) -> SaveDataSpaceId: ...
    def Initialize(self, isJournalingSupported: bool, isMultiCommitSupported: bool, isJournalingEnabled: bool, timeStampGetter: ISaveDataCommitTimeStampGetter, randomGenerator: RandomDataGenerator) -> Result: ...
    def IsSaveDataFileSystemCacheEnabled(self) -> bool: ...
    def ReadExtraData(self, extraData: clr.Reference[SaveDataExtraData]) -> Result: ...
    def RegisterExtraDataAccessorObserver(self, observer: ISaveDataExtraDataAccessorObserver, spaceId: SaveDataSpaceId, saveDataId: int) -> None: ...
    def RollbackOnlyModified(self) -> Result: ...
    def WriteExtraData(self, extraData: clr.Reference[SaveDataExtraData]) -> Result: ...


class DistributionType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Download : DistributionType # 0
    GameCard : DistributionType # 1


class FileSystemBuddyHeap(IDisposable):
    def __init__(self) -> None: ...
    def AllocateBufferByOrder(self, order: int) -> Buffer: ...
    def AllocateByOrder(self, order: int) -> clr.Reference[None]: ...
    def Dispose(self) -> None: ...
    def Dump(self) -> None: ...
    def GetAllocatableSizeMax(self) -> UIntPtr: ...
    @staticmethod
    def GetBlockCountFromOrder(order: int) -> int: ...
    def GetBlockSize(self) -> UIntPtr: ...
    def GetBytesFromOrder(self, order: int) -> UIntPtr: ...
    def GetOrderFromBytes(self, size: UIntPtr) -> int: ...
    def GetOrderMax(self) -> int: ...
    def GetTotalFreeSize(self) -> UIntPtr: ...
    @staticmethod
    def QueryOrderMax(size: UIntPtr, blockSize: UIntPtr) -> int: ...
    @staticmethod
    def QueryWorkBufferSize(orderMax: int) -> UIntPtr: ...
    # Skipped Free due to it being static, abstract and generic.

    Free : Free_MethodGroup
    class Free_MethodGroup:
        @typing.overload
        def __call__(self, buffer: Buffer) -> None:...
        @typing.overload
        def __call__(self, pointer: clr.Reference[None], order: int) -> None:...

    # Skipped Initialize due to it being static, abstract and generic.

    Initialize : Initialize_MethodGroup
    class Initialize_MethodGroup:
        @typing.overload
        def __call__(self, heapBuffer: Memory_1[int], blockSize: int) -> Result:...
        @typing.overload
        def __call__(self, address: UIntPtr, size: UIntPtr, blockSize: UIntPtr) -> Result:...
        @typing.overload
        def __call__(self, heapBuffer: Memory_1[int], blockSize: int, orderMax: int) -> Result:...
        @typing.overload
        def __call__(self, heapBuffer: Memory_1[int], blockSize: int, workBuffer: Memory_1[int]) -> Result:...
        @typing.overload
        def __call__(self, address: UIntPtr, size: UIntPtr, blockSize: UIntPtr, orderMax: int) -> Result:...
        @typing.overload
        def __call__(self, heapBuffer: Memory_1[int], blockSize: int, orderMax: int, workBuffer: Memory_1[int]) -> Result:...
        @typing.overload
        def __call__(self, address: UIntPtr, size: UIntPtr, blockSize: UIntPtr, workBuffer: clr.Reference[None], workBufferSize: UIntPtr) -> Result:...
        @typing.overload
        def __call__(self, address: UIntPtr, size: UIntPtr, blockSize: UIntPtr, orderMax: int, workBuffer: clr.Reference[None], workBufferSize: UIntPtr) -> Result:...



class FileSystemBufferManager(IBufferManager):
    def __init__(self) -> None: ...
    def Dispose(self) -> None: ...
    # Skipped Initialize due to it being static, abstract and generic.

    Initialize : Initialize_MethodGroup
    class Initialize_MethodGroup:
        @typing.overload
        def __call__(self, maxCacheCount: int, heapBuffer: Memory_1[int], blockSize: int) -> Result:...
        @typing.overload
        def __call__(self, maxCacheCount: int, heapBuffer: Memory_1[int], blockSize: int, maxOrder: int) -> Result:...
        @typing.overload
        def __call__(self, maxCacheCount: int, heapBuffer: Memory_1[int], blockSize: int, workBuffer: Memory_1[int]) -> Result:...
        @typing.overload
        def __call__(self, maxCacheCount: int, heapBuffer: Memory_1[int], blockSize: int, maxOrder: int, workBuffer: Memory_1[int]) -> Result:...



class FileSystemBufferManagerSet:
    def __init__(self) -> None: ...
    Buffers : Array_1[IBufferManager]


class ForwardingDirectory(IDirectory):
    def Dispose(self) -> None: ...


class ForwardingFile(IFile):
    def Dispose(self) -> None: ...


class ForwardingFileSystem(IFileSystem):
    def Dispose(self) -> None: ...


class GenerateKeyFunction(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, destKey: Span_1[int], sourceKey: ReadOnlySpan_1[int], keyType: int, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, destKey: Span_1[int], sourceKey: ReadOnlySpan_1[int], keyType: int) -> None: ...


class GetDecompressorFunction(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, compressionType: CompressionType, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> DecompressorFunction: ...
    def Invoke(self, compressionType: CompressionType) -> DecompressorFunction: ...


class Hash:
    Value : Array32_1[int]


class HashAlgorithmType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Sha2 : HashAlgorithmType # 0
    Sha3 : HashAlgorithmType # 1


class HierarchicalIntegrityVerificationInformation:
    HashSalt : HashSalt
    Layers : Array6_1[HierarchicalIntegrityVerificationLevelInformation]
    MaxLayers : int


class HierarchicalIntegrityVerificationLevelInformation:
    BlockOrder : int
    Offset : Int64
    Reserved : int
    Size : Int64


class HierarchicalIntegrityVerificationMetaInformation:
    LevelHashInfo : HierarchicalIntegrityVerificationInformation
    Magic : int
    MasterHashSize : int
    Version : int
    # Skipped Format due to it being static, abstract and generic.

    Format : Format_MethodGroup
    class Format_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, hashSalt: clr.Reference[Optional_1[HashSalt]]) -> None:...



class HierarchicalIntegrityVerificationSizeSet:
    ControlSize : int
    LayeredHashSizes : Array5_1[int]
    MasterHashSize : int


class HierarchicalIntegrityVerificationStorage(IStorage):
    def __init__(self, fsServer: FileSystemServer) -> None: ...
    @classmethod
    @property
    def L1Key(cls) -> ReadOnlySpan_1[int]: ...
    @classmethod
    @property
    def L2Key(cls) -> ReadOnlySpan_1[int]: ...
    @classmethod
    @property
    def L3Key(cls) -> ReadOnlySpan_1[int]: ...
    @classmethod
    @property
    def L4Key(cls) -> ReadOnlySpan_1[int]: ...
    @classmethod
    @property
    def L5Key(cls) -> ReadOnlySpan_1[int]: ...
    @classmethod
    @property
    def MasterKey(cls) -> ReadOnlySpan_1[int]: ...
    def Commit(self) -> Result: ...
    def Dispose(self) -> None: ...
    def FinalizeObject(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetBuffers(self) -> FileSystemBufferManagerSet: ...
    @staticmethod
    def GetDefaultDataCacheBufferLevel(maxLayers: int) -> int: ...
    def GetL1HashStorage(self) -> ValueSubStorage: ...
    def GetL1HashVerificationBlockSize(self) -> int: ...
    def GetParameters(self, outParam: clr.Reference[HierarchicalIntegrityVerificationStorageControlArea.InputParam]) -> None: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def IsInitialized(self) -> bool: ...
    def OnRollback(self) -> Result: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    @staticmethod
    def SetGenerateRandomFunction(fsServer: FileSystemServer, function: RandomDataGenerator) -> None: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...
    # Skipped Initialize due to it being static, abstract and generic.

    Initialize : Initialize_MethodGroup
    class Initialize_MethodGroup:
        @typing.overload
        def __call__(self, info: clr.Reference[HierarchicalIntegrityVerificationInformation], storageInfo: clr.Reference[HierarchicalIntegrityVerificationStorage.HierarchicalStorageInformation], buffers: FileSystemBufferManagerSet, hashGeneratorFactory: IHash256GeneratorFactory, isHashSaltEnabled: bool, mutex: SdkRecursiveMutex, maxDataCacheEntries: int, maxHashCacheEntries: int, bufferLevel: int, isWritable: bool, allowClearedBlocks: bool) -> Result:...
        @typing.overload
        def __call__(self, info: clr.Reference[HierarchicalIntegrityVerificationInformation], storageInfo: clr.Reference[HierarchicalIntegrityVerificationStorage.HierarchicalStorageInformation], buffers: FileSystemBufferManagerSet, hashGeneratorFactory: IHash256GeneratorFactory, isHashSaltEnabled: bool, mutex: SdkRecursiveMutex, readSemaphore: Semaphore, writeSemaphore: Semaphore, maxDataCacheEntries: int, maxHashCacheEntries: int, bufferLevel: int, isWritable: bool, allowClearedBlocks: bool) -> Result:...


    class HierarchicalStorageInformation(IDisposable):
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, other: clr.Reference[HierarchicalIntegrityVerificationStorage.HierarchicalStorageInformation]) -> None: ...
        @property
        def Item(self) -> clr.Reference[ValueSubStorage]: ...
        def Dispose(self) -> None: ...
        def SetDataStorage(self, storage: clr.Reference[ValueSubStorage]) -> None: ...
        def SetLayer1HashStorage(self, storage: clr.Reference[ValueSubStorage]) -> None: ...
        def SetLayer2HashStorage(self, storage: clr.Reference[ValueSubStorage]) -> None: ...
        def SetLayer3HashStorage(self, storage: clr.Reference[ValueSubStorage]) -> None: ...
        def SetLayer4HashStorage(self, storage: clr.Reference[ValueSubStorage]) -> None: ...
        def SetLayer5HashStorage(self, storage: clr.Reference[ValueSubStorage]) -> None: ...
        def SetMasterHashStorage(self, storage: clr.Reference[ValueSubStorage]) -> None: ...

        class Storage(typing.SupportsInt):
            @typing.overload
            def __init__(self, value : int) -> None: ...
            @typing.overload
            def __init__(self, value : int, force_if_true: bool) -> None: ...
            def __int__(self) -> int: ...
            
            # Values:
            MasterStorage : HierarchicalIntegrityVerificationStorage.HierarchicalStorageInformation.Storage # 0
            Layer1Storage : HierarchicalIntegrityVerificationStorage.HierarchicalStorageInformation.Storage # 1
            Layer2Storage : HierarchicalIntegrityVerificationStorage.HierarchicalStorageInformation.Storage # 2
            Layer3Storage : HierarchicalIntegrityVerificationStorage.HierarchicalStorageInformation.Storage # 3
            Layer4Storage : HierarchicalIntegrityVerificationStorage.HierarchicalStorageInformation.Storage # 4
            Layer5Storage : HierarchicalIntegrityVerificationStorage.HierarchicalStorageInformation.Storage # 5
            DataStorage : HierarchicalIntegrityVerificationStorage.HierarchicalStorageInformation.Storage # 6




class HierarchicalIntegrityVerificationStorageControlArea(IDisposable):
    def __init__(self) -> None: ...
    HashSize : int
    def Dispose(self) -> None: ...
    @staticmethod
    def Expand(metaStorage: clr.Reference[ValueSubStorage], newMeta: clr.Reference[HierarchicalIntegrityVerificationMetaInformation]) -> Result: ...
    def FinalizeObject(self) -> None: ...
    @staticmethod
    def Format(metaStorage: clr.Reference[ValueSubStorage], metaInfo: clr.Reference[HierarchicalIntegrityVerificationMetaInformation]) -> Result: ...
    def GetLevelHashInfo(self, outInfo: clr.Reference[HierarchicalIntegrityVerificationInformation]) -> None: ...
    def GetMasterHashSize(self) -> int: ...
    def Initialize(self, metaStorage: clr.Reference[ValueSubStorage]) -> Result: ...
    @staticmethod
    def QuerySize(outSizeSet: clr.Reference[HierarchicalIntegrityVerificationSizeSet], inputParam: clr.Reference[HierarchicalIntegrityVerificationStorageControlArea.InputParam], layerCount: int, dataSize: int) -> Result: ...

    class InputParam:
        LevelBlockSizes : Array6_1[int]



class IAlignmentMatchingStorageSize(typing.Protocol):
    pass


class IAsynchronousAccessSplitter(IDisposable, typing.Protocol):
    @staticmethod
    def GetDefaultAsynchronousAccessSplitter() -> IAsynchronousAccessSplitter: ...
    @abc.abstractmethod
    def QueryAppropriateOffset(self, offsetAppropriate: clr.Reference[int], startOffset: int, accessSize: int, alignmentSize: int) -> Result: ...
    def QueryInvocationCount(self, count: clr.Reference[int], startOffset: int, endOffset: int, accessSize: int, alignmentSize: int) -> Result: ...
    def QueryNextOffset(self, nextOffset: clr.Reference[int], startOffset: int, endOffset: int, accessSize: int, alignmentSize: int) -> Result: ...


class ICacheableSaveDataFileSystem(typing.Protocol):
    @abc.abstractmethod
    def IsSaveDataFileSystemCacheEnabled(self) -> bool: ...
    @abc.abstractmethod
    def RollbackOnlyModified(self) -> Result: ...


class IHash256Generator(IDisposable, abc.ABC):
    HashSize : int
    def Dispose(self) -> None: ...
    def GetHash(self, hashBuffer: Span_1[int]) -> None: ...
    def Initialize(self) -> None: ...
    def Update(self, data: ReadOnlySpan_1[int]) -> None: ...


class IHash256GeneratorFactory(IDisposable, abc.ABC):
    def Create(self, outGenerator: clr.Reference[UniqueRef_1[IHash256Generator]]) -> Result: ...
    def Dispose(self) -> None: ...
    def GenerateHash(self, hashBuffer: Span_1[int], data: ReadOnlySpan_1[int]) -> None: ...


class IHash256GeneratorFactorySelector(IDisposable, abc.ABC):
    def Dispose(self) -> None: ...
    def GetFactory(self, type: HashAlgorithmType) -> IHash256GeneratorFactory: ...


class IndirectStorage(IStorage):
    def __init__(self) -> None: ...
    NodeSize : int
    StorageCount : int
    def Dispose(self) -> None: ...
    def FinalizeObject(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetEntryList(self, entryBuffer: Span_1[IndirectStorage.Entry], outputEntryCount: clr.Reference[int], offset: int, size: int) -> Result: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def IsInitialized(self) -> bool: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    @staticmethod
    def QueryEntryStorageSize(entryCount: int) -> int: ...
    @staticmethod
    def QueryHeaderStorageSize() -> int: ...
    @staticmethod
    def QueryNodeStorageSize(entryCount: int) -> int: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...
    # Skipped Initialize due to it being static, abstract and generic.

    Initialize : Initialize_MethodGroup
    class Initialize_MethodGroup:
        @typing.overload
        def __call__(self, allocator: MemoryResource, tableStorage: clr.Reference[ValueSubStorage]) -> Result:...
        @typing.overload
        def __call__(self, allocator: MemoryResource, nodeStorage: clr.Reference[ValueSubStorage], entryStorage: clr.Reference[ValueSubStorage], entryCount: int) -> Result:...

    # Skipped SetStorage due to it being static, abstract and generic.

    SetStorage : SetStorage_MethodGroup
    class SetStorage_MethodGroup:
        @typing.overload
        def __call__(self, index: int, storage: clr.Reference[ValueSubStorage]) -> None:...
        @typing.overload
        def __call__(self, index: int, storage: IStorage, offset: int, size: int) -> None:...


    class Entry:
        StorageIndex : int
        def GetPhysicalOffset(self) -> int: ...
        def GetVirtualOffset(self) -> int: ...
        def SetPhysicalOffset(self, offset: int) -> None: ...
        def SetVirtualOffset(self, offset: int) -> None: ...


    class EntryData:
        PhysicalOffset : int
        StorageIndex : int
        VirtualOffset : int
        def Set(self, entry: clr.Reference[IndirectStorage.Entry]) -> None: ...



class IntegrityRomFsStorage(IStorage):
    def __init__(self, fsServer: FileSystemServer) -> None: ...
    def Dispose(self) -> None: ...
    def FinalizeObject(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def Initialize(self, info: clr.Reference[HierarchicalIntegrityVerificationInformation], masterHash: Hash, storageInfo: clr.Reference[HierarchicalIntegrityVerificationStorage.HierarchicalStorageInformation], bufferManager: IBufferManager, maxDataCacheEntries: int, maxHashCacheEntries: int, bufferLevel: int, hashGeneratorFactory: IHash256GeneratorFactory) -> Result: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...


class IntegrityVerificationStorage(IStorage):
    def __init__(self) -> None: ...
    HashSize : int
    def CalcBlockHash(self, outHash: clr.Reference[IntegrityVerificationStorage.BlockHash], buffer: ReadOnlySpan_1[int], verificationBlockSize: int) -> Result: ...
    def Dispose(self) -> None: ...
    def FinalizeObject(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetBlockSize(self) -> int: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def Initialize(self, hashStorage: clr.Reference[ValueSubStorage], dataStorage: clr.Reference[ValueSubStorage], sizeVerificationBlock: int, sizeUpperLayerVerificationBlock: int, bufferManager: IBufferManager, hashGeneratorFactory: IHash256GeneratorFactory, hashSalt: clr.Reference[Optional_1[HashSalt]], isRealData: bool, isWritable: bool, allowClearedBlocks: bool) -> None: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...

    class BlockHash:
        Hash : Array32_1[int]



class IResultConvertDirectory(IDirectory):
    def Dispose(self) -> None: ...


class IResultConvertFile(IFile):
    def Dispose(self) -> None: ...


class IResultConvertFileSystem_GenericClasses(abc.ABCMeta):
    Generic_IResultConvertFileSystem_GenericClasses_IResultConvertFileSystem_1_T = typing.TypeVar('Generic_IResultConvertFileSystem_GenericClasses_IResultConvertFileSystem_1_T')
    def __getitem__(self, types : typing.Type[Generic_IResultConvertFileSystem_GenericClasses_IResultConvertFileSystem_1_T]) -> typing.Type[IResultConvertFileSystem_1[Generic_IResultConvertFileSystem_GenericClasses_IResultConvertFileSystem_1_T]]: ...

IResultConvertFileSystem : IResultConvertFileSystem_GenericClasses

IResultConvertFileSystem_1_T = typing.TypeVar('IResultConvertFileSystem_1_T')
class IResultConvertFileSystem_1(typing.Generic[IResultConvertFileSystem_1_T], ISaveDataFileSystem):
    def Dispose(self) -> None: ...


class ISaveDataCommitTimeStampGetter(typing.Protocol):
    @abc.abstractmethod
    def Get(self, timeStamp: clr.Reference[int]) -> Result: ...


class ISaveDataExtraDataAccessor(IDisposable, typing.Protocol):
    @abc.abstractmethod
    def CommitExtraData(self, updateTimeStamp: bool) -> Result: ...
    @abc.abstractmethod
    def ReadExtraData(self, extraData: clr.Reference[SaveDataExtraData]) -> Result: ...
    @abc.abstractmethod
    def RegisterExtraDataAccessorObserver(self, observer: ISaveDataExtraDataAccessorObserver, spaceId: SaveDataSpaceId, saveDataId: int) -> None: ...
    @abc.abstractmethod
    def WriteExtraData(self, extraData: clr.Reference[SaveDataExtraData]) -> Result: ...


class ISaveDataExtraDataAccessorObserver(IDisposable, typing.Protocol):
    @abc.abstractmethod
    def Unregister(self, spaceId: SaveDataSpaceId, saveDataId: int) -> None: ...


class ISaveDataFileSystem(IFileSystem, ISaveDataExtraDataAccessor, ICacheableSaveDataFileSystem):
    @abc.abstractmethod
    def CommitExtraData(self, updateTimeStamp: bool) -> Result: ...
    @abc.abstractmethod
    def IsSaveDataFileSystemCacheEnabled(self) -> bool: ...
    @abc.abstractmethod
    def ReadExtraData(self, extraData: clr.Reference[SaveDataExtraData]) -> Result: ...
    @abc.abstractmethod
    def RegisterExtraDataAccessorObserver(self, observer: ISaveDataExtraDataAccessorObserver, spaceId: SaveDataSpaceId, saveDataId: int) -> None: ...
    @abc.abstractmethod
    def RollbackOnlyModified(self) -> Result: ...
    @abc.abstractmethod
    def WriteExtraData(self, extraData: clr.Reference[SaveDataExtraData]) -> Result: ...


class IUniqueLock(IDisposable, typing.Protocol):
    pass


class KeyType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    NcaHeaderKey1 : KeyType # 96
    NcaHeaderKey2 : KeyType # 97
    NcaExternalKey : KeyType # 98
    SaveDataDeviceUniqueMac : KeyType # 99
    SaveDataSeedUniqueMac : KeyType # 100
    SaveDataTransferMac : KeyType # 101
    ZeroKey : KeyType # -2
    InvalidKey : KeyType # -1


class LocalDirectory(IDirectory):
    def __init__(self, entryEnumerator: IEnumerator_1[FileSystemInfo], dirInfo: DirectoryInfo, mode: OpenDirectoryMode) -> None: ...


class LocalFile(IFile):
    @typing.overload
    def __init__(self, path: str, mode: OpenMode) -> None: ...
    @typing.overload
    def __init__(self, stream: FileStream, mode: OpenMode) -> None: ...
    def Dispose(self) -> None: ...


class LocalFileSystem(IAttributeFileSystem):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, fsClient: FileSystemClient, useUnixTimeStamps: bool) -> None: ...
    @typing.overload
    def __init__(self, rootPath: str) -> None: ...
    @typing.overload
    def __init__(self, useUnixTimeStamps: bool) -> None: ...
    @staticmethod
    def Create(fileSystem: clr.Reference[LocalFileSystem], rootPath: str, pathMode: LocalFileSystem.PathMode = ..., ensurePathExists: bool = ...) -> Result: ...
    @staticmethod
    def GetCaseSensitivePath(bytesWritten: clr.Reference[int], buffer: Span_1[int], path: U8Span, workingDirectoryPath: U8Span) -> Result: ...
    @staticmethod
    def GetCorrectCasedPath(casedPath: clr.Reference[str], path: str) -> Result: ...
    def Initialize(self, rootPath: str, pathMode: LocalFileSystem.PathMode, ensurePathExists: bool) -> Result: ...

    class PathMode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        DefaultCaseSensitivity : LocalFileSystem.PathMode # 0
        CaseSensitive : LocalFileSystem.PathMode # 1



class LocalStorage(IStorage):
    @typing.overload
    def __init__(self, path: str, access: FileAccess) -> None: ...
    @typing.overload
    def __init__(self, path: str, access: FileAccess, mode: FileMode) -> None: ...
    def Dispose(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...


class LruListCache_GenericClasses(abc.ABCMeta):
    Generic_LruListCache_GenericClasses_LruListCache_2_TKey = typing.TypeVar('Generic_LruListCache_GenericClasses_LruListCache_2_TKey')
    Generic_LruListCache_GenericClasses_LruListCache_2_TValue = typing.TypeVar('Generic_LruListCache_GenericClasses_LruListCache_2_TValue')
    def __getitem__(self, types : typing.Tuple[typing.Type[Generic_LruListCache_GenericClasses_LruListCache_2_TKey], typing.Type[Generic_LruListCache_GenericClasses_LruListCache_2_TValue]]) -> typing.Type[LruListCache_2[Generic_LruListCache_GenericClasses_LruListCache_2_TKey, Generic_LruListCache_GenericClasses_LruListCache_2_TValue]]: ...

LruListCache : LruListCache_GenericClasses

LruListCache_2_TKey = typing.TypeVar('LruListCache_2_TKey')
LruListCache_2_TValue = typing.TypeVar('LruListCache_2_TValue')
class LruListCache_2(typing.Generic[LruListCache_2_TKey, LruListCache_2_TValue]):
    def __init__(self) -> None: ...
    def DeleteAllNodes(self) -> None: ...
    def FindValueAndUpdateMru(self, value: clr.Reference[LruListCache_2_TValue], key: LruListCache_2_TKey) -> bool: ...
    def GetSize(self) -> int: ...
    def IsEmpty(self) -> bool: ...
    def PopLruNode(self) -> LinkedListNode_1[LruListCache_2.Node_2[LruListCache_2_TKey, LruListCache_2_TValue]]: ...
    def PushMruNode(self, node: LinkedListNode_1[LruListCache_2.Node_2[LruListCache_2_TKey, LruListCache_2_TValue]], key: LruListCache_2_TKey) -> None: ...

    Node_GenericClasses_LruListCache_2_TKey = typing.TypeVar('Node_GenericClasses_LruListCache_2_TKey')
    Node_GenericClasses_LruListCache_2_TValue = typing.TypeVar('Node_GenericClasses_LruListCache_2_TValue')
    class Node_GenericClasses(typing.Generic[Node_GenericClasses_LruListCache_2_TKey, Node_GenericClasses_LruListCache_2_TValue], abc.ABCMeta):
        Node_GenericClasses_LruListCache_2_TKey = LruListCache_2.Node_GenericClasses_LruListCache_2_TKey
        Node_GenericClasses_LruListCache_2_TValue = LruListCache_2.Node_GenericClasses_LruListCache_2_TValue
        def __call__(self) -> LruListCache_2.Node_2[Node_GenericClasses_LruListCache_2_TKey, Node_GenericClasses_LruListCache_2_TValue]: ...

    Node : Node_GenericClasses[LruListCache_2_TKey, LruListCache_2_TValue]

    Node_2_TKey = typing.TypeVar('Node_2_TKey')
    Node_2_TValue = typing.TypeVar('Node_2_TValue')
    class Node_2(typing.Generic[Node_2_TKey, Node_2_TValue]):
        Node_2_TKey = LruListCache_2.Node_2_TKey
        Node_2_TValue = LruListCache_2.Node_2_TValue
        def __init__(self, value: Node_2_TValue) -> None: ...
        Key : Node_2_TKey
        Value : Node_2_TValue



class MemoryResourceBufferHoldStorage(IStorage):
    def __init__(self, baseStorage: clr.Reference[SharedRef_1[IStorage]], memoryResource: MemoryResource, bufferSize: int) -> None: ...
    def Dispose(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetBuffer(self) -> Buffer: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def IsValid(self) -> bool: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...


class NcaAesCtrUpperIv:
    Generation : int
    SecureValue : int
    Value : int


class NcaCompressionConfiguration:
    GetDecompressorFunc : GetDecompressorFunction


class NcaCompressionInfo:
    Reserved : int
    TableHeader : Array16_1[int]
    TableOffset : int
    TableSize : int


class NcaContentType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Program : NcaContentType # 0
    Meta : NcaContentType # 1
    Control : NcaContentType # 2
    Manual : NcaContentType # 3
    Data : NcaContentType # 4
    PublicData : NcaContentType # 5


class NcaCryptoConfiguration:
    Aes128KeySize : int
    DecryptAesCtr : DecryptAesCtrFunction
    DecryptAesCtrForExternalKey : DecryptAesCtrFunction
    DecryptAesXtsForExternalKey : CryptAesXtsFunction
    EncryptAesXtsForExternalKey : CryptAesXtsFunction
    GenerateKey : GenerateKeyFunction
    Header1SignatureKeyGenerationMax : int
    Header1SignKeyModuli : Array2_1[Array256_1[int]]
    Header1SignKeyPublicExponent : Array3_1[int]
    HeaderEncryptedEncryptionKeys : Array2_1[Array16_1[int]]
    HeaderEncryptionKeyCount : int
    HeaderEncryptionKeySource : Array16_1[int]
    IsAvailableSwKey : bool
    IsDev : bool
    KeyAreaEncryptionKeyCount : int
    KeyAreaEncryptionKeyIndexCount : int
    KeyAreaEncryptionKeyIndexZeroKey : int
    KeyAreaEncryptionKeySources : Array3_1[Array16_1[int]]
    KeyGenerationMax : int
    Rsa2048KeyModulusSize : int
    Rsa2048KeyPrivateExponentSize : int
    Rsa2048KeyPublicExponentSize : int
    VerifySign1 : VerifySign1Function


class NcaEncryptionType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Auto : NcaEncryptionType # 0
    None_ : NcaEncryptionType # 1
    XTS : NcaEncryptionType # 2
    AesCtr : NcaEncryptionType # 3
    AesCtrEx : NcaEncryptionType # 4


class NcaFileSystemDriver(IDisposable):
    @typing.overload
    def __init__(self, ncaReader: clr.Reference[SharedRef_1[NcaReader]], allocator: MemoryResource, bufferManager: IBufferManager, hashGeneratorFactorySelector: IHash256GeneratorFactorySelector) -> None: ...
    @typing.overload
    def __init__(self, originalNcaReader: clr.Reference[SharedRef_1[NcaReader]], currentNcaReader: clr.Reference[SharedRef_1[NcaReader]], allocator: MemoryResource, bufferManager: IBufferManager, hashGeneratorFactorySelector: IHash256GeneratorFactorySelector) -> None: ...
    def CreateRegionSwitchStorage(self, outStorage: clr.Reference[SharedRef_1[IStorage]], headerReader: NcaFsHeaderReader, insideRegionStorage: clr.Reference[SharedRef_1[IStorage]], outsideRegionStorage: clr.Reference[SharedRef_1[IStorage]]) -> Result: ...
    def Dispose(self) -> None: ...
    def OpenStorage(self, outStorage: clr.Reference[SharedRef_1[IStorage]], outStorageAccessSplitter: clr.Reference[SharedRef_1[IAsynchronousAccessSplitter]], outHeaderReader: clr.Reference[NcaFsHeaderReader], fsIndex: int) -> Result: ...
    # Skipped CreateCompressedStorage due to it being static, abstract and generic.

    CreateCompressedStorage : CreateCompressedStorage_MethodGroup
    class CreateCompressedStorage_MethodGroup:
        @typing.overload
        def __call__(self, outStorage: clr.Reference[SharedRef_1[IStorage]], outCompressedStorage: clr.Reference[SharedRef_1[CompressedStorage]], outMetaStorage: clr.Reference[SharedRef_1[IStorage]], baseStorage: clr.Reference[SharedRef_1[IStorage]], compressionInfo: clr.Reference[NcaCompressionInfo]) -> Result:...
        @typing.overload
        def __call__(self, outStorage: clr.Reference[SharedRef_1[IStorage]], outCompressedStorage: clr.Reference[SharedRef_1[CompressedStorage]], outMetaStorage: clr.Reference[SharedRef_1[IStorage]], baseStorage: clr.Reference[SharedRef_1[IStorage]], compressionInfo: clr.Reference[NcaCompressionInfo], getDecompressor: GetDecompressorFunction, allocator: MemoryResource, bufferManager: IBufferManager) -> Result:...


    class StorageContext(IDisposable):
        AesCtrExStorage : SharedRef_1[AesCtrCounterExtendedStorage]
        AesCtrExStorageDataStorage : SharedRef_1[IStorage]
        AesCtrExStorageMetaStorage : SharedRef_1[IStorage]
        BodySubStorage : SharedRef_1[IStorage]
        CompressedStorage : SharedRef_1[CompressedStorage]
        CompressedStorageMetaStorage : SharedRef_1[IStorage]
        CurrentSparseStorage : SharedRef_1[SparseStorage]
        FsDataStorage : SharedRef_1[IStorage]
        IndirectStorage : SharedRef_1[IndirectStorage]
        IndirectStorageMetaStorage : SharedRef_1[IStorage]
        OpenRawStorage : bool
        OriginalSparseStorage : SharedRef_1[SparseStorage]
        PatchLayerInfoStorage : SharedRef_1[IStorage]
        SparseLayerInfoStorage : SharedRef_1[IStorage]
        SparseStorageMetaStorage : SharedRef_1[IStorage]
        def Dispose(self) -> None: ...



class NcaFormatType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Romfs : NcaFormatType # 0
    Pfs0 : NcaFormatType # 1


class NcaFsHeader:
    AesCtrUpperIv : NcaAesCtrUpperIv
    CompressionInfo : NcaCompressionInfo
    EncryptionTypeValue : NcaFsHeader.EncryptionType
    FsTypeValue : NcaFsHeader.FsType
    HashDataValue : NcaFsHeader.HashData
    HashTypeValue : NcaFsHeader.HashType
    MetaDataHashDataInfo : NcaMetaDataHashDataInfo
    MetaDataHashTypeValue : NcaFsHeader.MetaDataHashType
    Padding : Array48_1[int]
    PatchInfo : NcaPatchInfo
    Reserved : Array2_1[int]
    SparseInfo : NcaSparseInfo
    Version : int
    def GetHashTargetOffset(self, outOffset: clr.Reference[int]) -> Result: ...
    def IsSkipLayerHashEncryption(self) -> bool: ...

    class EncryptionType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Auto : NcaFsHeader.EncryptionType # 0
        None_ : NcaFsHeader.EncryptionType # 1
        AesXts : NcaFsHeader.EncryptionType # 2
        AesCtr : NcaFsHeader.EncryptionType # 3
        AesCtrEx : NcaFsHeader.EncryptionType # 4
        AesCtrSkipLayerHash : NcaFsHeader.EncryptionType # 5
        AesCtrExSkipLayerHash : NcaFsHeader.EncryptionType # 6


    class FsType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        RomFs : NcaFsHeader.FsType # 0
        PartitionFs : NcaFsHeader.FsType # 1


    class HashData:
        HierarchicalSha256 : NcaFsHeader.HashData.HierarchicalSha256Data
        IntegrityMeta : NcaFsHeader.HashData.IntegrityMetaInfo

        class HierarchicalSha256Data:
            BlockSize : int
            LayerCount : int
            LayerRegions : Array5_1[NcaFsHeader.Region]
            MasterHash : Hash


        class IntegrityMetaInfo:
            LevelHashInfo : NcaFsHeader.HashData.IntegrityMetaInfo.InfoLevelHash
            Magic : int
            MasterHash : Hash
            MasterHashSize : int
            Version : int

            class InfoLevelHash:
                Layers : Array6_1[NcaFsHeader.HashData.IntegrityMetaInfo.InfoLevelHash.HierarchicalIntegrityVerificationLevelInformation]
                MaxLayers : int
                Salt : NcaFsHeader.HashData.IntegrityMetaInfo.InfoLevelHash.SignatureSalt

                class HierarchicalIntegrityVerificationLevelInformation:
                    Offset : Int64
                    OrderBlock : int
                    Reserved : Array4_1[int]
                    Size : Int64


                class SignatureSalt:
                    Value : Array32_1[int]





    class HashType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Auto : NcaFsHeader.HashType # 0
        None_ : NcaFsHeader.HashType # 1
        HierarchicalSha256Hash : NcaFsHeader.HashType # 2
        HierarchicalIntegrityHash : NcaFsHeader.HashType # 3
        AutoSha3 : NcaFsHeader.HashType # 4
        HierarchicalSha3256Hash : NcaFsHeader.HashType # 5
        HierarchicalIntegritySha3Hash : NcaFsHeader.HashType # 6


    class MetaDataHashType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        None_ : NcaFsHeader.MetaDataHashType # 0
        HierarchicalIntegrity : NcaFsHeader.MetaDataHashType # 1


    class Region:
        Offset : int
        Size : int



class NcaFsHeaderReader:
    def __init__(self) -> None: ...
    def ExistsCompressionLayer(self) -> bool: ...
    def ExistsPatchMetaHashLayer(self) -> bool: ...
    def ExistsSparseLayer(self) -> bool: ...
    def ExistsSparseMetaHashLayer(self) -> bool: ...
    def GetAesCtrUpperIv(self) -> NcaAesCtrUpperIv: ...
    def GetCompressionInfo(self) -> clr.Reference[NcaCompressionInfo]: ...
    def GetEncryptionType(self) -> NcaFsHeader.EncryptionType: ...
    def GetFsIndex(self) -> int: ...
    def GetFsType(self) -> NcaFsHeader.FsType: ...
    def GetHashData(self) -> clr.Reference[NcaFsHeader.HashData]: ...
    def GetHashTargetOffset(self, outOffset: clr.Reference[int]) -> Result: ...
    def GetHashType(self) -> NcaFsHeader.HashType: ...
    def GetPatchInfo(self) -> clr.Reference[NcaPatchInfo]: ...
    def GetPatchMetaDataHashDataInfo(self) -> clr.Reference[NcaMetaDataHashDataInfo]: ...
    def GetPatchMetaHashType(self) -> NcaFsHeader.MetaDataHashType: ...
    def GetRawData(self, outBuffer: Span_1[int]) -> None: ...
    def GetSparseInfo(self) -> clr.Reference[NcaSparseInfo]: ...
    def GetSparseMetaDataHashDataInfo(self) -> clr.Reference[NcaMetaDataHashDataInfo]: ...
    def GetSparseMetaHashType(self) -> NcaFsHeader.MetaDataHashType: ...
    def GetVersion(self) -> int: ...
    def Initialize(self, reader: NcaReader, index: int) -> Result: ...
    def IsInitialized(self) -> bool: ...
    def IsSkipLayerHashEncryption(self) -> bool: ...


class NcaHashType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Auto : NcaHashType # 0
    None_ : NcaHashType # 1
    Sha256 : NcaHashType # 2
    Ivfc : NcaHashType # 3


class NcaHeader:
    ContentIndex : int
    ContentSize : int
    ContentTypeValue : NcaHeader.ContentType
    CtrBlockSize : int
    CurrentMagic : int
    DistributionTypeValue : NcaHeader.DistributionType
    EncryptedKeyAreaSize : int
    EncryptedKeys : Array256_1[int]
    FsCountMax : int
    FsHeaderHashes : Array4_1[Hash]
    FsInfos : Array4_1[NcaHeader.FsInfo]
    Header1SignatureKeyGeneration : int
    HeaderSignCount : int
    HeaderSignSize : int
    KeyAreaEncryptionKeyIndex : int
    KeyGeneration1 : int
    KeyGeneration2 : int
    Magic : int
    Magic0 : int
    Magic1 : int
    Magic2 : int
    Magic3 : int
    ProgramId : int
    Reserved222 : Array2_1[int]
    Reserved224 : Array3_1[int]
    RightsId : Array16_1[int]
    RightsIdSize : int
    SdkAddonVersion : int
    SectorShift : int
    SectorSize : int
    Signature1 : Array256_1[int]
    Signature2 : Array256_1[int]
    Size : int
    XtsBlockSize : int
    @staticmethod
    def ByteToSector(byteIndex: int) -> int: ...
    def GetProperKeyGeneration(self) -> int: ...
    @staticmethod
    def SectorToByte(sectorIndex: int) -> int: ...

    class ContentType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Program : NcaHeader.ContentType # 0
        Meta : NcaHeader.ContentType # 1
        Control : NcaHeader.ContentType # 2
        Manual : NcaHeader.ContentType # 3
        Data : NcaHeader.ContentType # 4
        PublicData : NcaHeader.ContentType # 5


    class DecryptionKey(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        AesXts : NcaHeader.DecryptionKey # 0
        AesXts1 : NcaHeader.DecryptionKey # 0
        AesXts2 : NcaHeader.DecryptionKey # 1
        AesCtr : NcaHeader.DecryptionKey # 2
        AesCtrEx : NcaHeader.DecryptionKey # 3
        AesCtrHw : NcaHeader.DecryptionKey # 4
        Count : NcaHeader.DecryptionKey # 5


    class DistributionType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Download : NcaHeader.DistributionType # 0
        GameCard : NcaHeader.DistributionType # 1


    class EncryptionType(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Auto : NcaHeader.EncryptionType # 0
        None_ : NcaHeader.EncryptionType # 1


    class FsInfo:
        EndSector : int
        HashSectors : int
        Reserved : int
        StartSector : int



class NcaKeyFunctions(abc.ABC):
    @staticmethod
    def GetKeyTypeValue(keyIndex: int, keyGeneration: int) -> int: ...
    @staticmethod
    def IsInvalidKeyTypeValue(keyType: int) -> bool: ...


class NcaMetaDataHashData:
    IntegrityMetaInfo : NcaFsHeader.HashData.IntegrityMetaInfo
    LayerInfoOffset : int


class NcaMetaDataHashDataInfo:
    Hash : Hash
    Offset : int
    Size : int


class NcaPatchInfo:
    AesCtrExHeader : Array16_1[int]
    AesCtrExOffset : int
    AesCtrExSize : int
    IndirectHeader : Array16_1[int]
    IndirectOffset : int
    IndirectSize : int
    def HasAesCtrExTable(self) -> bool: ...
    def HasIndirectTable(self) -> bool: ...


class NcaReader(IDisposable):
    def __init__(self) -> None: ...
    def Dispose(self) -> None: ...
    def GetContentIndex(self) -> int: ...
    def GetContentSize(self) -> int: ...
    def GetContentType(self) -> NcaHeader.ContentType: ...
    def GetDecompressor(self) -> GetDecompressorFunction: ...
    def GetDecryptionKey(self, index: int) -> ReadOnlySpan_1[int]: ...
    def GetDistributionType(self) -> NcaHeader.DistributionType: ...
    def GetEncryptedKey(self, outBuffer: Span_1[int]) -> None: ...
    def GetEncryptionType(self) -> NcaHeader.EncryptionType: ...
    def GetExternalDecryptAesCtrFunction(self) -> DecryptAesCtrFunction: ...
    def GetExternalDecryptAesCtrFunctionForExternalKey(self) -> DecryptAesCtrFunction: ...
    def GetExternalDecryptionKey(self) -> ReadOnlySpan_1[int]: ...
    def GetFsCount(self) -> int: ...
    def GetFsEndOffset(self, index: int) -> int: ...
    def GetFsInfo(self, outFsInfo: clr.Reference[NcaHeader.FsInfo], index: int) -> None: ...
    def GetFsOffset(self, index: int) -> int: ...
    def GetFsSize(self, index: int) -> int: ...
    def GetHashGeneratorFactorySelector(self) -> IHash256GeneratorFactorySelector: ...
    def GetHeaderSign2(self, outBuffer: Span_1[int]) -> None: ...
    def GetHeaderSign2TargetHash(self, outBuffer: Span_1[int]) -> None: ...
    def GetKeyGeneration(self) -> int: ...
    def GetKeyIndex(self) -> int: ...
    def GetProgramId(self) -> int: ...
    def GetRawData(self, outBuffer: Span_1[int]) -> None: ...
    def GetRightsId(self, outBuffer: Span_1[int]) -> None: ...
    def GetSdkAddonVersion(self) -> int: ...
    def GetSharedBodyStorage(self) -> SharedRef_1[IStorage]: ...
    def GetSignature(self) -> int: ...
    def HasExternalDecryptionKey(self) -> bool: ...
    def HasFsInfo(self, index: int) -> bool: ...
    def HasInternalDecryptionKeyForAesHw(self) -> bool: ...
    def HasValidInternalKey(self) -> bool: ...
    def Initialize(self, baseStorage: clr.Reference[SharedRef_1[IStorage]], cryptoConfig: clr.Reference[NcaCryptoConfiguration], compressionConfig: clr.Reference[NcaCompressionConfiguration], hashGeneratorFactorySelector: IHash256GeneratorFactorySelector) -> Result: ...
    def IsAvailableSwKey(self) -> bool: ...
    def IsSwAesPrioritized(self) -> bool: ...
    def PrioritizeSwAes(self) -> None: ...
    def ReadHeader(self, outHeader: clr.Reference[NcaFsHeader], index: int) -> Result: ...
    def SetExternalDecryptionKey(self, key: ReadOnlySpan_1[int]) -> None: ...
    # Skipped GetFsHeaderHash due to it being static, abstract and generic.

    GetFsHeaderHash : GetFsHeaderHash_MethodGroup
    class GetFsHeaderHash_MethodGroup:
        @typing.overload
        def __call__(self, index: int) -> clr.Reference[Hash]:...
        @typing.overload
        def __call__(self, outHash: clr.Reference[Hash], index: int) -> None:...



class NcaSectionType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Code : NcaSectionType # 0
    Data : NcaSectionType # 1
    Logo : NcaSectionType # 2


class NcaSparseInfo:
    Generation : int
    MetaHeader : Array16_1[int]
    MetaOffset : int
    MetaSize : int
    PhysicalOffset : int
    Reserved : Array6_1[int]
    def GetGeneration(self) -> int: ...
    def GetPhysicalSize(self) -> int: ...
    def MakeAesCtrUpperIv(self, upperIv: NcaAesCtrUpperIv) -> NcaAesCtrUpperIv: ...


class PartitionDirectory(IDirectory):
    def __init__(self, fs: PartitionFileSystem, path: str, mode: OpenDirectoryMode) -> None: ...


class PartitionFile(IFile):
    def __init__(self, baseStorage: IStorage, offset: int, size: int, mode: OpenMode) -> None: ...


class PartitionFileEntry:
    def __init__(self, reader: BinaryReader, type: PartitionFileSystemType) -> None: ...
    Hash : Array_1[int]
    HashedRegionOffset : int
    HashedRegionSize : int
    HashValidity : Validity
    Index : int
    Name : str
    Offset : int
    Size : int
    StringTableOffset : int
    @staticmethod
    def GetEntrySize(type: PartitionFileSystemType) -> int: ...


class PartitionFileSystem(IFileSystem):
    def __init__(self, storage: IStorage) -> None: ...
    @property
    def Files(self) -> Array_1[PartitionFileEntry]: ...
    @property
    def Header(self) -> PartitionFileSystemHeader: ...
    @property
    def HeaderSize(self) -> int: ...
    def OpenFile(self, entry: PartitionFileEntry, mode: OpenMode) -> IFile: ...


class PartitionFileSystemCore_GenericClasses(abc.ABCMeta):
    Generic_PartitionFileSystemCore_GenericClasses_PartitionFileSystemCore_1_T = typing.TypeVar('Generic_PartitionFileSystemCore_GenericClasses_PartitionFileSystemCore_1_T')
    def __getitem__(self, types : typing.Type[Generic_PartitionFileSystemCore_GenericClasses_PartitionFileSystemCore_1_T]) -> typing.Type[PartitionFileSystemCore_1[Generic_PartitionFileSystemCore_GenericClasses_PartitionFileSystemCore_1_T]]: ...

PartitionFileSystemCore : PartitionFileSystemCore_GenericClasses

PartitionFileSystemCore_1_T = typing.TypeVar('PartitionFileSystemCore_1_T')
class PartitionFileSystemCore_1(typing.Generic[PartitionFileSystemCore_1_T], IFileSystem):
    def __init__(self) -> None: ...
    def Dispose(self) -> None: ...
    # Skipped Initialize due to it being static, abstract and generic.

    Initialize : Initialize_MethodGroup[PartitionFileSystemCore_1_T]
    Initialize_MethodGroup_PartitionFileSystemCore_1_T = typing.TypeVar('Initialize_MethodGroup_PartitionFileSystemCore_1_T')
    class Initialize_MethodGroup(typing.Generic[Initialize_MethodGroup_PartitionFileSystemCore_1_T]):
        Initialize_MethodGroup_PartitionFileSystemCore_1_T = PartitionFileSystemCore_1.Initialize_MethodGroup_PartitionFileSystemCore_1_T
        @typing.overload
        def __call__(self, baseStorage: IStorage) -> Result:...
        @typing.overload
        def __call__(self, baseStorage: clr.Reference[SharedRef_1[IStorage]]) -> Result:...



class PartitionFileSystemHeader:
    def __init__(self, reader: BinaryReader) -> None: ...
    Files : Array_1[PartitionFileEntry]
    HeaderSize : int
    Magic : str
    NumFiles : int
    Reserved : int
    StringTableSize : int
    Type : PartitionFileSystemType


class PartitionFileSystemMetaCore_GenericClasses(abc.ABCMeta):
    Generic_PartitionFileSystemMetaCore_GenericClasses_PartitionFileSystemMetaCore_1_T = typing.TypeVar('Generic_PartitionFileSystemMetaCore_GenericClasses_PartitionFileSystemMetaCore_1_T')
    def __getitem__(self, types : typing.Type[Generic_PartitionFileSystemMetaCore_GenericClasses_PartitionFileSystemMetaCore_1_T]) -> typing.Type[PartitionFileSystemMetaCore_1[Generic_PartitionFileSystemMetaCore_GenericClasses_PartitionFileSystemMetaCore_1_T]]: ...

PartitionFileSystemMetaCore : PartitionFileSystemMetaCore_GenericClasses

PartitionFileSystemMetaCore_1_T = typing.TypeVar('PartitionFileSystemMetaCore_1_T')
class PartitionFileSystemMetaCore_1(typing.Generic[PartitionFileSystemMetaCore_1_T]):
    def __init__(self) -> None: ...
    @property
    def Size(self) -> int: ...
    @Size.setter
    def Size(self, value: int) -> int: ...
    def FindEntry(self, name: U8Span) -> int: ...
    def GetEntry(self, index: int) -> clr.Reference[PartitionFileSystemMetaCore_1_T]: ...
    def GetEntryCount(self) -> int: ...
    def GetName(self, index: int) -> U8Span: ...
    def Initialize(self, baseStorage: IStorage) -> Result: ...


class PartitionFileSystemType(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    Standard : PartitionFileSystemType # 0
    Hashed : PartitionFileSystemType # 1


class PooledBuffer(IDisposable):
    def __init__(self, idealSize: int, requiredSize: int) -> None: ...
    @classmethod
    @property
    def GetAllocatableParticularlyLargeSizeMax(cls) -> int: ...
    def Allocate(self, idealSize: int, requiredSize: int) -> None: ...
    def AllocateParticularlyLarge(self, idealSize: int, requiredSize: int) -> None: ...
    def Deallocate(self) -> None: ...
    def Dispose(self) -> None: ...
    @staticmethod
    def GetAllocatableSizeMax() -> int: ...
    def GetSize(self) -> int: ...
    def Shrink(self, idealSize: int) -> None: ...
    # Skipped GetBuffer due to it being static, abstract and generic.

    GetBuffer : GetBuffer_MethodGroup
    class GetBuffer_MethodGroup:
        def __getitem__(self, t:typing.Type[GetBuffer_1_T1]) -> GetBuffer_1[GetBuffer_1_T1]: ...

        GetBuffer_1_T1 = typing.TypeVar('GetBuffer_1_T1')
        class GetBuffer_1(typing.Generic[GetBuffer_1_T1]):
            GetBuffer_1_T = PooledBuffer.GetBuffer_MethodGroup.GetBuffer_1_T1
            def __call__(self) -> Span_1[GetBuffer_1_T]:...

        def __call__(self) -> Span_1[int]:...



class PooledBufferGlobalMethods(abc.ABC):
    @staticmethod
    def ClearPooledBufferPeak(fsSrv: FileSystemServer) -> None: ...
    @staticmethod
    def GetPooledBufferFailedIdealAllocationCountOnAsyncAccess(fsSrv: FileSystemServer) -> int: ...
    @staticmethod
    def GetPooledBufferFreeSizePeak(fsSrv: FileSystemServer) -> int: ...
    @staticmethod
    def GetPooledBufferReduceAllocationCount(fsSrv: FileSystemServer) -> int: ...
    @staticmethod
    def GetPooledBufferRetriedCount(fsSrv: FileSystemServer) -> int: ...
    @staticmethod
    def IsAdditionalDeviceAddress(buffer: ReadOnlySpan_1[int]) -> bool: ...
    @staticmethod
    def IsDeviceAddress(buffer: ReadOnlySpan_1[int]) -> bool: ...
    @staticmethod
    def IsPooledBuffer(buffer: ReadOnlySpan_1[int]) -> bool: ...


class RandomDataGenerator(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, buffer: Span_1[int], callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> None: ...
    def Invoke(self, buffer: Span_1[int]) -> None: ...


class ReadOnlyBlockCacheStorage(IStorage):
    def __init__(self, baseStorage: clr.Reference[SharedRef_1[IStorage]], blockSize: int, buffer: Memory_1[int], cacheBlockCount: int) -> None: ...
    def Dispose(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...


class RegionSwitchStorage(IStorage):
    def __init__(self, insideRegionStorage: clr.Reference[SharedRef_1[IStorage]], outsideRegionStorage: clr.Reference[SharedRef_1[IStorage]], region: RegionSwitchStorage.Region) -> None: ...
    def Dispose(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...

    class Region:
        Offset : int
        Size : int



class ScopedThreadPriorityChanger(IDisposable):
    def __init__(self, priority: int, mode: ScopedThreadPriorityChanger.Mode) -> None: ...
    def Dispose(self) -> None: ...

    class Mode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Absolute : ScopedThreadPriorityChanger.Mode # 0
        Relative : ScopedThreadPriorityChanger.Mode # 1



class ScopedThreadPriorityChangerByAccessPriority(IDisposable):
    def __init__(self, mode: ScopedThreadPriorityChangerByAccessPriority.AccessMode) -> None: ...
    def Dispose(self) -> None: ...

    class AccessMode(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        Read : ScopedThreadPriorityChangerByAccessPriority.AccessMode # 0
        Write : ScopedThreadPriorityChangerByAccessPriority.AccessMode # 1



class SemaphoreAdapter(ILockable, IDisposable):
    def __init__(self, initialCount: int, maxCount: int) -> None: ...
    def Dispose(self) -> None: ...
    def Lock(self) -> None: ...
    def TryLock(self) -> bool: ...
    def Unlock(self) -> None: ...


class SparseStorage(IndirectStorage):
    def __init__(self) -> None: ...
    def Dispose(self) -> None: ...
    def Initialize(self, size: int) -> None: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetDataStorage(self, storage: clr.Reference[ValueSubStorage]) -> None: ...


class StorageFile(IFile):
    def __init__(self, baseStorage: IStorage, mode: OpenMode) -> None: ...


class SubdirectoryFileSystem(IFileSystem):
    @typing.overload
    def __init__(self, baseFileSystem: IFileSystem) -> None: ...
    @typing.overload
    def __init__(self, baseFileSystem: clr.Reference[SharedRef_1[IFileSystem]]) -> None: ...
    def Dispose(self) -> None: ...
    def Initialize(self, rootPath: clr.Reference[Path]) -> Result: ...


class SwitchStorage(IStorage):
    def __init__(self, trueStorage: clr.Reference[SharedRef_1[IStorage]], falseStorage: clr.Reference[SharedRef_1[IStorage]], storageSelectionFunction: Func_1[bool]) -> None: ...
    def Dispose(self) -> None: ...
    def Flush(self) -> Result: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...


class TruncatedSubStorage(SubStorage):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, other: SubStorage) -> None: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...


class UnionStorage(IStorage):
    def __init__(self) -> None: ...
    def Commit(self) -> Result: ...
    def Dispose(self) -> None: ...
    def Flush(self) -> Result: ...
    @staticmethod
    def Format(storage: clr.Reference[ValueSubStorage], blockSize: int) -> Result: ...
    def Freeze(self) -> Result: ...
    def GetSize(self, size: clr.Reference[int]) -> Result: ...
    def Initialize(self, baseStorage: clr.Reference[ValueSubStorage], logStorage: clr.Reference[ValueSubStorage], blockSize: int) -> Result: ...
    def OperateRange(self, outBuffer: Span_1[int], operationId: OperationId, offset: int, size: int, inBuffer: ReadOnlySpan_1[int]) -> Result: ...
    def Read(self, offset: int, destination: Span_1[int]) -> Result: ...
    def SetSize(self, size: int) -> Result: ...
    def Write(self, offset: int, source: ReadOnlySpan_1[int]) -> Result: ...


class UniqueLockWithPin_GenericClasses(abc.ABCMeta):
    Generic_UniqueLockWithPin_GenericClasses_UniqueLockWithPin_1_T = typing.TypeVar('Generic_UniqueLockWithPin_GenericClasses_UniqueLockWithPin_1_T')
    def __getitem__(self, types : typing.Type[Generic_UniqueLockWithPin_GenericClasses_UniqueLockWithPin_1_T]) -> typing.Type[UniqueLockWithPin_1[Generic_UniqueLockWithPin_GenericClasses_UniqueLockWithPin_1_T]]: ...

UniqueLockWithPin : UniqueLockWithPin_GenericClasses

UniqueLockWithPin_1_T = typing.TypeVar('UniqueLockWithPin_1_T')
class UniqueLockWithPin_1(typing.Generic[UniqueLockWithPin_1_T], IUniqueLock):
    def __init__(self, semaphore: clr.Reference[UniqueLock_1[SemaphoreAdapter]], pinnedObject: clr.Reference[SharedRef_1[UniqueLockWithPin_1_T]]) -> None: ...
    def Dispose(self) -> None: ...


class VerifySign1Function(MulticastDelegate):
    def __init__(self, object: typing.Any, method: int) -> None: ...
    @property
    def Method(self) -> MethodInfo: ...
    @property
    def Target(self) -> typing.Any: ...
    def BeginInvoke(self, signature: ReadOnlySpan_1[int], data: ReadOnlySpan_1[int], isProd: bool, generation: int, callback: AsyncCallback, object: typing.Any) -> IAsyncResult: ...
    def EndInvoke(self, result: IAsyncResult) -> bool: ...
    def Invoke(self, signature: ReadOnlySpan_1[int], data: ReadOnlySpan_1[int], isProd: bool, generation: int) -> bool: ...


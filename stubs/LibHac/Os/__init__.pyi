import typing, clr, abc
from System.Threading import WaitHandle
from LibHac import TimeSpan
from LibHac.Os.Impl import MultiWaitHolderImpl, MultiWaitImpl, InternalCriticalSection
from System import IDisposable, IEquatable_1

class ConditionVariableStatus(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    TimedOut : ConditionVariableStatus # 0
    Success : ConditionVariableStatus # 1


class DeferLock:
    pass


class IBasicLockable(typing.Protocol):
    @abc.abstractmethod
    def Lock(self) -> None: ...
    @abc.abstractmethod
    def Unlock(self) -> None: ...


class ILockable(IBasicLockable, typing.Protocol):
    @abc.abstractmethod
    def TryLock(self) -> bool: ...


class ISharedMutex(ILockable, typing.Protocol):
    @abc.abstractmethod
    def LockShared(self) -> None: ...
    @abc.abstractmethod
    def TryLockShared(self) -> bool: ...
    @abc.abstractmethod
    def UnlockShared(self) -> None: ...


class ITickGenerator(typing.Protocol):
    @abc.abstractmethod
    def GetCurrentTick(self) -> Tick: ...


class MemoryFenceApi(abc.ABC):
    @staticmethod
    def FenceMemoryAnyAny() -> None: ...
    @staticmethod
    def FenceMemoryAnyLoad() -> None: ...
    @staticmethod
    def FenceMemoryAnyStore() -> None: ...
    @staticmethod
    def FenceMemoryLoadAny() -> None: ...
    @staticmethod
    def FenceMemoryLoadLoad() -> None: ...
    @staticmethod
    def FenceMemoryLoadStore() -> None: ...
    @staticmethod
    def FenceMemoryStoreAny() -> None: ...
    @staticmethod
    def FenceMemoryStoreLoad() -> None: ...
    @staticmethod
    def FenceMemoryStoreStore() -> None: ...


class MultipleWait(abc.ABC):
    @staticmethod
    def FinalizeMultiWait(os: OsState, multiWait: MultiWaitType) -> None: ...
    @staticmethod
    def FinalizeMultiWaitHolder(os: OsState, holder: MultiWaitHolderType) -> None: ...
    @staticmethod
    def GetMultiWaitHolderUserData(os: OsState, holder: MultiWaitHolderType) -> typing.Any: ...
    @staticmethod
    def InitializeMultiWait(os: OsState, multiWait: MultiWaitType) -> None: ...
    @staticmethod
    def InitializeMultiWaitHolder(os: OsState, holder: MultiWaitHolderType, handle: WaitHandle) -> None: ...
    @staticmethod
    def LinkMultiWaitHolder(os: OsState, multiWait: MultiWaitType, holder: MultiWaitHolderType) -> None: ...
    @staticmethod
    def MoveAllMultiWaitHolder(os: OsState, dest: MultiWaitType, source: MultiWaitType) -> None: ...
    @staticmethod
    def SetMultiWaitHolderUserData(os: OsState, holder: MultiWaitHolderType, userData: typing.Any) -> None: ...
    @staticmethod
    def TimedWaitAny(os: OsState, multiWait: MultiWaitType, timeout: TimeSpan) -> MultiWaitHolderType: ...
    @staticmethod
    def TryWaitAny(os: OsState, multiWait: MultiWaitType) -> MultiWaitHolderType: ...
    @staticmethod
    def UnlinkAllMultiWaitHolder(os: OsState, multiWait: MultiWaitType) -> None: ...
    @staticmethod
    def UnlinkMultiWaitHolder(os: OsState, holder: MultiWaitHolderType) -> None: ...
    @staticmethod
    def WaitAny(os: OsState, multiWait: MultiWaitType) -> MultiWaitHolderType: ...


class MultiWaitHolderType:
    def __init__(self) -> None: ...
    Impl : MultiWaitHolderImpl
    UserData : typing.Any


class MultiWaitType:
    def __init__(self) -> None: ...
    CurrentState : MultiWaitType.State
    Impl : MultiWaitImpl
    IsWaiting : bool

    class State(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        NotInitialized : MultiWaitType.State # 0
        Initialized : MultiWaitType.State # 1



class NativeHandleApi(abc.ABC):
    @staticmethod
    def CloseNativeHandle(os: OsState, handle: typing.Any) -> None: ...


class OsState(IDisposable):
    @property
    def Impl(self) -> OsStateImpl: ...
    def Dispose(self) -> None: ...
    def GetCurrentProcessId(self) -> ProcessId: ...


class OsStateImpl:
    pass


class OsTypes(abc.ABC):
    @classmethod
    @property
    def InvalidNativeHandle(cls) -> WaitHandle: ...


class ProcessId:
    def __init__(self, value: int) -> None: ...
    Value : int
    @classmethod
    @property
    def InvalidId(cls) -> ProcessId: ...


class ReaderWriterLock(ISharedMutex, IDisposable):
    def __init__(self, os: OsState) -> None: ...
    ReaderWriterLockCountMax : int
    ReadWriteLockWaiterCountMax : int
    def AcquireReadLock(self) -> None: ...
    def AcquireWriteLock(self) -> None: ...
    def Dispose(self) -> None: ...
    def GetBase(self) -> clr.Reference[ReaderWriterLockType]: ...
    def IsLockOwner(self) -> bool: ...
    def IsReadLockHeld(self) -> bool: ...
    def IsWriteLockHeldByCurrentThread(self) -> bool: ...
    def Lock(self) -> None: ...
    def LockShared(self) -> None: ...
    def ReleaseReadLock(self) -> None: ...
    def ReleaseWriteLock(self) -> None: ...
    def TryAcquireReadLock(self) -> bool: ...
    def TryAcquireWriteLock(self) -> bool: ...
    def TryLock(self) -> bool: ...
    def TryLockShared(self) -> bool: ...
    def Unlock(self) -> None: ...
    def UnlockShared(self) -> None: ...


class ReaderWriterLockApi(abc.ABC):
    @staticmethod
    def AcquireReadLock(os: OsState, rwLock: clr.Reference[ReaderWriterLockType]) -> None: ...
    @staticmethod
    def AcquireWriteLock(os: OsState, rwLock: clr.Reference[ReaderWriterLockType]) -> None: ...
    @staticmethod
    def FinalizeReaderWriterLock(os: OsState, rwLock: clr.Reference[ReaderWriterLockType]) -> None: ...
    @staticmethod
    def InitializeReaderWriterLock(os: OsState, rwLock: clr.Reference[ReaderWriterLockType]) -> None: ...
    @staticmethod
    def IsReaderWriterLockOwnerThread(os: OsState, rwLock: clr.Reference[ReaderWriterLockType]) -> bool: ...
    @staticmethod
    def IsReadLockHeld(os: OsState, rwLock: clr.Reference[ReaderWriterLockType]) -> bool: ...
    @staticmethod
    def IsWriteLockHeldByCurrentThread(os: OsState, rwLock: clr.Reference[ReaderWriterLockType]) -> bool: ...
    @staticmethod
    def ReleaseReadLock(os: OsState, rwLock: clr.Reference[ReaderWriterLockType]) -> None: ...
    @staticmethod
    def ReleaseWriteLock(os: OsState, rwLock: clr.Reference[ReaderWriterLockType]) -> None: ...
    @staticmethod
    def TryAcquireReadLock(os: OsState, rwLock: clr.Reference[ReaderWriterLockType]) -> bool: ...
    @staticmethod
    def TryAcquireWriteLock(os: OsState, rwLock: clr.Reference[ReaderWriterLockType]) -> bool: ...


class ReaderWriterLockType:

    class LockCountType:
        Counter : ReaderWriterLockType.ReaderWriterLockCounter
        Cs : InternalCriticalSection
        WriteLockCount : int


    class ReaderWriterLockCounter:
        @property
        def ReadLockCount(self) -> int: ...
        @ReadLockCount.setter
        def ReadLockCount(self, value: int) -> int: ...
        @property
        def ReadLockWaiterCount(self) -> int: ...
        @ReadLockWaiterCount.setter
        def ReadLockWaiterCount(self, value: int) -> int: ...
        @property
        def WriteLocked(self) -> int: ...
        @WriteLocked.setter
        def WriteLocked(self, value: int) -> int: ...
        @property
        def WriteLockWaiterCount(self) -> int: ...
        @WriteLockWaiterCount.setter
        def WriteLockWaiterCount(self, value: int) -> int: ...


    class State(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        NotInitialized : ReaderWriterLockType.State # 0
        Initialized : ReaderWriterLockType.State # 1



class ScopedLock_GenericClasses(abc.ABCMeta):
    Generic_ScopedLock_GenericClasses_ScopedLock_1_TMutex = typing.TypeVar('Generic_ScopedLock_GenericClasses_ScopedLock_1_TMutex')
    def __getitem__(self, types : typing.Type[Generic_ScopedLock_GenericClasses_ScopedLock_1_TMutex]) -> typing.Type[ScopedLock_1[Generic_ScopedLock_GenericClasses_ScopedLock_1_TMutex]]: ...

class ScopedLock(ScopedLock_0, metaclass =ScopedLock_GenericClasses): ...

class ScopedLock_0(abc.ABC):
    # Skipped Lock due to it being static, abstract and generic.

    Lock : Lock_MethodGroup
    class Lock_MethodGroup:
        def __getitem__(self, t:typing.Type[Lock_1_T1]) -> Lock_1[Lock_1_T1]: ...

        Lock_1_T1 = typing.TypeVar('Lock_1_T1')
        class Lock_1(typing.Generic[Lock_1_T1]):
            Lock_1_TMutex = ScopedLock_0.Lock_MethodGroup.Lock_1_T1
            def __call__(self, lockable: clr.Reference[Lock_1_TMutex]) -> ScopedLock_1[Lock_1_TMutex]:...




ScopedLock_1_TMutex = typing.TypeVar('ScopedLock_1_TMutex')
class ScopedLock_1(typing.Generic[ScopedLock_1_TMutex]):
    def __init__(self, mutex: clr.Reference[ScopedLock_1_TMutex]) -> None: ...
    def Dispose(self) -> None: ...


class SdkMutex(ILockable):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...
    def IsLockedByCurrentThread(self) -> bool: ...
    def Lock(self) -> None: ...
    def TryLock(self) -> bool: ...
    def Unlock(self) -> None: ...


class SdkMutexType(ILockable):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...
    def IsLockedByCurrentThread(self) -> bool: ...
    def Lock(self) -> None: ...
    def TryLock(self) -> bool: ...
    def Unlock(self) -> None: ...


class SdkRecursiveMutex(IBasicLockable):
    def __init__(self) -> None: ...
    def IsLockedByCurrentThread(self) -> bool: ...
    def Lock(self) -> None: ...
    def Unlock(self) -> None: ...


class SdkRecursiveMutexType(ILockable):
    def __init__(self) -> None: ...
    def Initialize(self) -> None: ...
    def IsLockedByCurrentThread(self) -> bool: ...
    def Lock(self) -> None: ...
    def TryLock(self) -> bool: ...
    def Unlock(self) -> None: ...


class Semaphore(IDisposable):
    def __init__(self, os: OsState, initialCount: int, maxCount: int) -> None: ...
    def Acquire(self) -> None: ...
    def Dispose(self) -> None: ...
    def GetBase(self) -> clr.Reference[SemaphoreType]: ...
    def GetCurrentCount(self) -> int: ...
    def TimedAcquire(self, timeout: TimeSpan) -> bool: ...
    def TryAcquire(self) -> bool: ...
    # Skipped Release due to it being static, abstract and generic.

    Release : Release_MethodGroup
    class Release_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, count: int) -> None:...



class SemaphoreApi(abc.ABC):
    @staticmethod
    def AcquireSemaphore(os: OsState, semaphore: clr.Reference[SemaphoreType]) -> None: ...
    @staticmethod
    def FinalizeSemaphore(os: OsState, semaphore: clr.Reference[SemaphoreType]) -> None: ...
    @staticmethod
    def GetCurrentSemaphoreCount(os: OsState, semaphore: clr.Reference[SemaphoreType]) -> int: ...
    @staticmethod
    def InitializeMultiWaitHolder(os: OsState, holder: MultiWaitHolderType, semaphore: Semaphore) -> None: ...
    @staticmethod
    def InitializeSemaphore(os: OsState, semaphore: clr.Reference[SemaphoreType], initialCount: int, maxCount: int) -> None: ...
    @staticmethod
    def TimedAcquireSemaphore(os: OsState, semaphore: clr.Reference[SemaphoreType], timeout: TimeSpan) -> bool: ...
    @staticmethod
    def TryAcquireSemaphore(os: OsState, semaphore: clr.Reference[SemaphoreType]) -> bool: ...
    # Skipped ReleaseSemaphore due to it being static, abstract and generic.

    ReleaseSemaphore : ReleaseSemaphore_MethodGroup
    class ReleaseSemaphore_MethodGroup:
        @typing.overload
        def __call__(self, os: OsState, semaphore: clr.Reference[SemaphoreType]) -> None:...
        @typing.overload
        def __call__(self, os: OsState, semaphore: clr.Reference[SemaphoreType], count: int) -> None:...



class SemaphoreType(IDisposable):
    def __init__(self, os: OsState, initialCount: int, maxCount: int) -> None: ...
    def Acquire(self) -> None: ...
    def Dispose(self) -> None: ...
    def GetCurrentCount(self) -> int: ...
    def TimedAcquire(self, timeout: TimeSpan) -> bool: ...
    def TryAcquire(self) -> bool: ...
    # Skipped Release due to it being static, abstract and generic.

    Release : Release_MethodGroup
    class Release_MethodGroup:
        @typing.overload
        def __call__(self) -> None:...
        @typing.overload
        def __call__(self, count: int) -> None:...


    class State(typing.SupportsInt):
        @typing.overload
        def __init__(self, value : int) -> None: ...
        @typing.overload
        def __init__(self, value : int, force_if_true: bool) -> None: ...
        def __int__(self) -> int: ...
        
        # Values:
        NotInitialized : SemaphoreType.State # 0
        Initialized : SemaphoreType.State # 1



class Thread(abc.ABC):
    @staticmethod
    def SleepThread(os: OsState, time: TimeSpan) -> None: ...


class Tick(IEquatable_1[Tick]):
    def __init__(self, ticks: int) -> None: ...
    def GetHashCode(self) -> int: ...
    def GetInt64Value(self) -> int: ...
    def __add__(self, left: Tick, right: Tick) -> Tick: ...
    def __eq__(self, left: Tick, right: Tick) -> bool: ...
    def __gt__(self, left: Tick, right: Tick) -> bool: ...
    def __ge__(self, left: Tick, right: Tick) -> bool: ...
    def __ne__(self, left: Tick, right: Tick) -> bool: ...
    def __lt__(self, left: Tick, right: Tick) -> bool: ...
    def __le__(self, left: Tick, right: Tick) -> bool: ...
    def __sub__(self, left: Tick, right: Tick) -> Tick: ...
    def ToString(self) -> str: ...
    def ToTimeSpan(self, os: OsState) -> TimeSpan: ...
    # Skipped Equals due to it being static, abstract and generic.

    Equals : Equals_MethodGroup
    class Equals_MethodGroup:
        @typing.overload
        def __call__(self, other: Tick) -> bool:...
        @typing.overload
        def __call__(self, obj: typing.Any) -> bool:...



class TickApi(abc.ABC):
    @staticmethod
    def ConvertToTick(os: OsState, ts: TimeSpan) -> Tick: ...
    @staticmethod
    def ConvertToTimeSpan(os: OsState, tick: Tick) -> TimeSpan: ...
    @staticmethod
    def GetSystemTick(os: OsState) -> Tick: ...
    @staticmethod
    def GetSystemTickFrequency(os: OsState) -> int: ...
    @staticmethod
    def GetSystemTickOrdered(os: OsState) -> Tick: ...


class TriBool(typing.SupportsInt):
    @typing.overload
    def __init__(self, value : int) -> None: ...
    @typing.overload
    def __init__(self, value : int, force_if_true: bool) -> None: ...
    def __int__(self) -> int: ...
    
    # Values:
    False : TriBool # 0
    True : TriBool # 1
    Undefined : TriBool # 2


class UniqueLock_GenericClasses(abc.ABCMeta):
    Generic_UniqueLock_GenericClasses_UniqueLock_1_TMutex = typing.TypeVar('Generic_UniqueLock_GenericClasses_UniqueLock_1_TMutex')
    def __getitem__(self, types : typing.Type[Generic_UniqueLock_GenericClasses_UniqueLock_1_TMutex]) -> typing.Type[UniqueLock_1[Generic_UniqueLock_GenericClasses_UniqueLock_1_TMutex]]: ...

class UniqueLock(UniqueLock_0, metaclass =UniqueLock_GenericClasses): ...

class UniqueLock_0(abc.ABC):
    # Skipped Lock due to it being static, abstract and generic.

    Lock : Lock_MethodGroup
    class Lock_MethodGroup:
        def __getitem__(self, t:typing.Type[Lock_1_T1]) -> Lock_1[Lock_1_T1]: ...

        Lock_1_T1 = typing.TypeVar('Lock_1_T1')
        class Lock_1(typing.Generic[Lock_1_T1]):
            Lock_1_TMutex = UniqueLock_0.Lock_MethodGroup.Lock_1_T1
            @typing.overload
            def __call__(self, lockable: Lock_1_TMutex) -> UniqueLock_1[Lock_1_TMutex]:...
            @typing.overload
            def __call__(self, lockable: clr.Reference[Lock_1_TMutex]) -> UniqueLockRef_1[Lock_1_TMutex]:...


    # Skipped Ref due to it being static, abstract and generic.

    Ref : Ref_MethodGroup
    class Ref_MethodGroup:
        def __getitem__(self, t:typing.Type[Ref_1_T1]) -> Ref_1[Ref_1_T1]: ...

        Ref_1_T1 = typing.TypeVar('Ref_1_T1')
        class Ref_1(typing.Generic[Ref_1_T1]):
            Ref_1_T = UniqueLock_0.Ref_MethodGroup.Ref_1_T1
            @typing.overload
            def __call__(self, value: clr.Reference[UniqueLockRef_1[Ref_1_T]]) -> clr.Reference[UniqueLockRef_1[Ref_1_T]]:...
            @typing.overload
            def __call__(self, value: clr.Reference[UniqueLock_1[Ref_1_T]]) -> clr.Reference[UniqueLock_1[Ref_1_T]]:...




UniqueLock_1_TMutex = typing.TypeVar('UniqueLock_1_TMutex')
class UniqueLock_1(typing.Generic[UniqueLock_1_TMutex], IDisposable):
    @typing.overload
    def __init__(self, mutex: UniqueLock_1_TMutex) -> None: ...
    @typing.overload
    def __init__(self, mutex: UniqueLock_1_TMutex, tag: DeferLock) -> None: ...
    @typing.overload
    def __init__(self, other: clr.Reference[UniqueLock_1[UniqueLock_1_TMutex]]) -> None: ...
    def Dispose(self) -> None: ...
    def Lock(self) -> None: ...
    def Reset(self, mutex: UniqueLock_1_TMutex) -> None: ...
    def Set(self, other: clr.Reference[UniqueLock_1[UniqueLock_1_TMutex]]) -> None: ...
    def TryLock(self) -> bool: ...
    def Unlock(self) -> None: ...


class UniqueLockRef_GenericClasses(abc.ABCMeta):
    Generic_UniqueLockRef_GenericClasses_UniqueLockRef_1_TMutex = typing.TypeVar('Generic_UniqueLockRef_GenericClasses_UniqueLockRef_1_TMutex')
    def __getitem__(self, types : typing.Type[Generic_UniqueLockRef_GenericClasses_UniqueLockRef_1_TMutex]) -> typing.Type[UniqueLockRef_1[Generic_UniqueLockRef_GenericClasses_UniqueLockRef_1_TMutex]]: ...

UniqueLockRef : UniqueLockRef_GenericClasses

UniqueLockRef_1_TMutex = typing.TypeVar('UniqueLockRef_1_TMutex')
class UniqueLockRef_1(typing.Generic[UniqueLockRef_1_TMutex]):
    @typing.overload
    def __init__(self, mutex: clr.Reference[UniqueLockRef_1_TMutex]) -> None: ...
    @typing.overload
    def __init__(self, mutex: clr.Reference[UniqueLockRef_1_TMutex], tag: DeferLock) -> None: ...
    @typing.overload
    def __init__(self, other: clr.Reference[UniqueLockRef_1[UniqueLockRef_1_TMutex]]) -> None: ...
    def Dispose(self) -> None: ...
    def Lock(self) -> None: ...
    def Set(self, other: clr.Reference[UniqueLockRef_1[UniqueLockRef_1_TMutex]]) -> None: ...
    def TryLock(self) -> bool: ...
    def Unlock(self) -> None: ...


import typing, clr, abc
from LibHac.Os import ILockable, MultiWaitHolderType, TriBool, Semaphore, OsState, MultiWaitType, ITickGenerator, Tick
from System import IDisposable, Span_1
from LibHac import TimeSpan, Result
from System.Threading import WaitHandle

class InternalCriticalSection(ILockable, IDisposable):
    def __init__(self) -> None: ...
    def Dispose(self) -> None: ...
    def Enter(self) -> None: ...
    def FinalizeObject(self) -> None: ...
    def Initialize(self) -> None: ...
    def IsLockedByCurrentThread(self) -> bool: ...
    def Leave(self) -> None: ...
    def Lock(self) -> None: ...
    def TryEnter(self) -> bool: ...
    def TryLock(self) -> bool: ...
    def Unlock(self) -> None: ...


class MemoryFence(abc.ABC):
    @staticmethod
    def FenceMemoryAnyAny() -> None: ...
    @staticmethod
    def FenceMemoryAnyLoad() -> None: ...
    @staticmethod
    def FenceMemoryAnyStore() -> None: ...
    @staticmethod
    def FenceMemoryLoadAny() -> None: ...
    @staticmethod
    def FenceMemoryLoadLoad() -> None: ...
    @staticmethod
    def FenceMemoryLoadStore() -> None: ...
    @staticmethod
    def FenceMemoryStoreAny() -> None: ...
    @staticmethod
    def FenceMemoryStoreLoad() -> None: ...
    @staticmethod
    def FenceMemoryStoreStore() -> None: ...


class MultiWaitHolderBase(abc.ABC):
    @property
    def Holder(self) -> MultiWaitHolderType: ...
    @Holder.setter
    def Holder(self, value: MultiWaitHolderType) -> MultiWaitHolderType: ...
    @abc.abstractmethod
    def AddToObjectList(self) -> TriBool: ...
    def GetAbsoluteTimeToWakeup(self) -> TimeSpan: ...
    def GetMultiWait(self) -> MultiWaitImpl: ...
    @abc.abstractmethod
    def GetNativeHandle(self, handle: clr.Reference[WaitHandle]) -> bool: ...
    def IsLinked(self) -> bool: ...
    def IsNotLinked(self) -> bool: ...
    @abc.abstractmethod
    def IsSignaled(self) -> TriBool: ...
    @abc.abstractmethod
    def RemoveFromObjectList(self) -> None: ...
    def SetMultiWait(self, multiWait: MultiWaitImpl) -> None: ...


class MultiWaitHolderImpl:
    @typing.overload
    def __init__(self, holder: MultiWaitHolderOfNativeHandle) -> None: ...
    @typing.overload
    def __init__(self, holder: MultiWaitHolderOfSemaphore) -> None: ...
    @property
    def HolderBase(self) -> MultiWaitHolderBase: ...
    @property
    def HolderOfNativeHandle(self) -> MultiWaitHolderOfNativeHandle: ...
    @property
    def HolderOfSemaphore(self) -> MultiWaitHolderOfSemaphore: ...


class MultiWaitHolderOfNativeHandle(MultiWaitHolderOfNativeWaitObject):
    @property
    def Holder(self) -> MultiWaitHolderType: ...
    @Holder.setter
    def Holder(self, value: MultiWaitHolderType) -> MultiWaitHolderType: ...
    def GetNativeHandle(self, handle: clr.Reference[WaitHandle]) -> bool: ...
    def IsSignaled(self) -> TriBool: ...


class MultiWaitHolderOfNativeWaitObject(MultiWaitHolderBase):
    @property
    def Holder(self) -> MultiWaitHolderType: ...
    @Holder.setter
    def Holder(self, value: MultiWaitHolderType) -> MultiWaitHolderType: ...
    def AddToObjectList(self) -> TriBool: ...
    def RemoveFromObjectList(self) -> None: ...


class MultiWaitHolderOfSemaphore(MultiWaitHolderOfUserWaitObject):
    def __init__(self, semaphore: Semaphore) -> None: ...
    @property
    def Holder(self) -> MultiWaitHolderType: ...
    @Holder.setter
    def Holder(self, value: MultiWaitHolderType) -> MultiWaitHolderType: ...
    def AddToObjectList(self) -> TriBool: ...
    def IsSignaled(self) -> TriBool: ...
    def RemoveFromObjectList(self) -> None: ...


class MultiWaitHolderOfUserWaitObject(MultiWaitHolderBase):
    @property
    def Holder(self) -> MultiWaitHolderType: ...
    @Holder.setter
    def Holder(self, value: MultiWaitHolderType) -> MultiWaitHolderType: ...
    def GetNativeHandle(self, handle: clr.Reference[WaitHandle]) -> bool: ...


class MultiWaitImpl(IDisposable):
    def __init__(self, os: OsState, parent: MultiWaitType) -> None: ...
    MaximumHandleCount : int
    WaitCancelled : int
    WaitInvalid : int
    WaitTimedOut : int
    def ConstructObjectsArray(self, outHandles: Span_1[WaitHandle], outObjects: Span_1[MultiWaitHolderBase], num: int) -> int: ...
    def Dispose(self) -> None: ...
    def EraseAllFromList(self) -> None: ...
    def EraseFromList(self, holder: MultiWaitHolderBase) -> None: ...
    def GetCurrentTime(self) -> TimeSpan: ...
    def GetMultiWaitType(self) -> MultiWaitType: ...
    def IsListEmpty(self) -> bool: ...
    def IsListNotEmpty(self) -> bool: ...
    def MoveAllFromOther(self, other: MultiWaitImpl) -> None: ...
    def NotifyAndWakeupThread(self, holder: MultiWaitHolderBase) -> None: ...
    def PushBackToList(self, holder: MultiWaitHolderBase) -> None: ...
    def RecalcMultiWaitTimeout(self, outMinTimeout: clr.Reference[TimeSpan], endTime: TimeSpan) -> MultiWaitHolderBase: ...
    def ReplyAndReceive(self, outHolder: clr.Reference[MultiWaitHolderBase], replyTarget: WaitHandle) -> Result: ...
    def TimedWaitAny(self, timeout: TimeSpan) -> MultiWaitHolderBase: ...
    def TryWaitAny(self) -> MultiWaitHolderBase: ...
    def WaitAny(self) -> MultiWaitHolderBase: ...


class MultiWaitObjectList:
    def __init__(self) -> None: ...
    def BroadcastToUpdateObjectStateUnsafe(self) -> None: ...
    def EraseFromList(self, holderBase: MultiWaitHolderBase) -> None: ...
    def IsEmpty(self) -> bool: ...
    def PushBackToList(self, holderBase: MultiWaitHolderBase) -> None: ...
    def WakeupAllMultiWaitThreadsUnsafe(self) -> None: ...


class MultiWaitTargetImpl(IDisposable):
    def __init__(self, os: OsState) -> None: ...
    def CancelWait(self) -> None: ...
    def ClearCurrentThreadHandleForCancelWait(self) -> None: ...
    def Dispose(self) -> None: ...
    def ReplyAndReceive(self, index: clr.Reference[int], handles: Span_1[WaitHandle], num: int, replyTarget: WaitHandle) -> Result: ...
    def SetCurrentThreadHandleForCancelWait(self) -> None: ...
    def TimedReplyAndReceive(self, index: clr.Reference[int], handles: Span_1[WaitHandle], num: int, replyTarget: WaitHandle, timeout: TimeSpan) -> Result: ...
    def TimedWaitAny(self, outIndex: clr.Reference[int], handles: Span_1[WaitHandle], num: int, timeout: TimeSpan) -> Result: ...
    def WaitAny(self, index: clr.Reference[int], handles: Span_1[WaitHandle], num: int) -> Result: ...


class TickManager(IDisposable):
    def __init__(self, tickGenerator: ITickGenerator) -> None: ...
    def ConvertToTick(self, ts: TimeSpan) -> Tick: ...
    def ConvertToTimespan(self, tick: Tick) -> TimeSpan: ...
    def Dispose(self) -> None: ...
    def GetMaxTick(self) -> int: ...
    def GetMaxTimeSpanNs(self) -> int: ...
    def GetSystemTickOrdered(self) -> Tick: ...
    def GetTick(self) -> Tick: ...
    def GetTickFrequency(self) -> int: ...

